// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace zte {
namespace netanalysis {
namespace capcontrol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class StartCapReq;
class StartCapRes;
class StopCapReq;
class StopCapRes;
class IpStatNotify;
class TcpStatNotify;
class TcpStatNotify_DirStat;
class TcpSessionNotify;
class TcpSessionNotify_IpPort;
class TcpSessionNotify_FlowInfo;
class DnsTransNotify;

enum MsgType {
  START_CAP_REQ = 1,
  START_CAP_RES = 2,
  STOP_CAP_REQ = 3,
  STOP_CAP_RES = 4,
  IP_STAT_NOTIFY = 5,
  TCP_STAT_NOTIFY = 6,
  TCP_SES_NOTIFY = 7,
  DNS_TRANS_NOTIFY = 8
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = START_CAP_REQ;
const MsgType MsgType_MAX = DNS_TRANS_NOTIFY;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

// ===================================================================

class StartCapReq : public ::google::protobuf::MessageLite {
 public:
  StartCapReq();
  virtual ~StartCapReq();

  StartCapReq(const StartCapReq& from);

  inline StartCapReq& operator=(const StartCapReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StartCapReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartCapReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartCapReq* other);

  // implements Message ----------------------------------------------

  StartCapReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartCapReq& from);
  void MergeFrom(const StartCapReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seq = 1;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 1;
  inline ::google::protobuf::int32 seq() const;
  inline void set_seq(::google::protobuf::int32 value);

  // optional string url = 2;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional string saveFile = 3;
  inline bool has_savefile() const;
  inline void clear_savefile();
  static const int kSaveFileFieldNumber = 3;
  inline const ::std::string& savefile() const;
  inline void set_savefile(const ::std::string& value);
  inline void set_savefile(const char* value);
  inline void set_savefile(const char* value, size_t size);
  inline ::std::string* mutable_savefile();
  inline ::std::string* release_savefile();
  inline void set_allocated_savefile(::std::string* savefile);

  // optional uint32 tcpStatInterval = 4;
  inline bool has_tcpstatinterval() const;
  inline void clear_tcpstatinterval();
  static const int kTcpStatIntervalFieldNumber = 4;
  inline ::google::protobuf::uint32 tcpstatinterval() const;
  inline void set_tcpstatinterval(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.zte.netanalysis.capcontrol.StartCapReq)
 private:
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_savefile();
  inline void clear_has_savefile();
  inline void set_has_tcpstatinterval();
  inline void clear_has_tcpstatinterval();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* url_;
  ::google::protobuf::int32 seq_;
  ::google::protobuf::uint32 tcpstatinterval_;
  ::std::string* savefile_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static StartCapReq* default_instance_;
};
// -------------------------------------------------------------------

class StartCapRes : public ::google::protobuf::MessageLite {
 public:
  StartCapRes();
  virtual ~StartCapRes();

  StartCapRes(const StartCapRes& from);

  inline StartCapRes& operator=(const StartCapRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StartCapRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartCapRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartCapRes* other);

  // implements Message ----------------------------------------------

  StartCapRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartCapRes& from);
  void MergeFrom(const StartCapRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seq = 1;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 1;
  inline ::google::protobuf::int32 seq() const;
  inline void set_seq(::google::protobuf::int32 value);

  // required int32 ack = 2;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 2;
  inline ::google::protobuf::int32 ack() const;
  inline void set_ack(::google::protobuf::int32 value);

  // required uint64 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.zte.netanalysis.capcontrol.StartCapRes)
 private:
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_ack();
  inline void clear_has_ack();
  inline void set_has_time();
  inline void clear_has_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 seq_;
  ::google::protobuf::int32 ack_;
  ::google::protobuf::uint64 time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static StartCapRes* default_instance_;
};
// -------------------------------------------------------------------

class StopCapReq : public ::google::protobuf::MessageLite {
 public:
  StopCapReq();
  virtual ~StopCapReq();

  StopCapReq(const StopCapReq& from);

  inline StopCapReq& operator=(const StopCapReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StopCapReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StopCapReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StopCapReq* other);

  // implements Message ----------------------------------------------

  StopCapReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StopCapReq& from);
  void MergeFrom(const StopCapReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seq = 1;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 1;
  inline ::google::protobuf::int32 seq() const;
  inline void set_seq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.zte.netanalysis.capcontrol.StopCapReq)
 private:
  inline void set_has_seq();
  inline void clear_has_seq();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 seq_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static StopCapReq* default_instance_;
};
// -------------------------------------------------------------------

class StopCapRes : public ::google::protobuf::MessageLite {
 public:
  StopCapRes();
  virtual ~StopCapRes();

  StopCapRes(const StopCapRes& from);

  inline StopCapRes& operator=(const StopCapRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StopCapRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StopCapRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StopCapRes* other);

  // implements Message ----------------------------------------------

  StopCapRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StopCapRes& from);
  void MergeFrom(const StopCapRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seq = 1;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 1;
  inline ::google::protobuf::int32 seq() const;
  inline void set_seq(::google::protobuf::int32 value);

  // required uint64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // optional uint32 totalSecs = 3;
  inline bool has_totalsecs() const;
  inline void clear_totalsecs();
  static const int kTotalSecsFieldNumber = 3;
  inline ::google::protobuf::uint32 totalsecs() const;
  inline void set_totalsecs(::google::protobuf::uint32 value);

  // optional uint32 totalPktNum = 4;
  inline bool has_totalpktnum() const;
  inline void clear_totalpktnum();
  static const int kTotalPktNumFieldNumber = 4;
  inline ::google::protobuf::uint32 totalpktnum() const;
  inline void set_totalpktnum(::google::protobuf::uint32 value);

  // optional uint32 droppedPktNum = 5;
  inline bool has_droppedpktnum() const;
  inline void clear_droppedpktnum();
  static const int kDroppedPktNumFieldNumber = 5;
  inline ::google::protobuf::uint32 droppedpktnum() const;
  inline void set_droppedpktnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.zte.netanalysis.capcontrol.StopCapRes)
 private:
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_totalsecs();
  inline void clear_has_totalsecs();
  inline void set_has_totalpktnum();
  inline void clear_has_totalpktnum();
  inline void set_has_droppedpktnum();
  inline void clear_has_droppedpktnum();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::int32 seq_;
  ::google::protobuf::uint32 totalsecs_;
  ::google::protobuf::uint32 totalpktnum_;
  ::google::protobuf::uint32 droppedpktnum_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static StopCapRes* default_instance_;
};
// -------------------------------------------------------------------

class IpStatNotify : public ::google::protobuf::MessageLite {
 public:
  IpStatNotify();
  virtual ~IpStatNotify();

  IpStatNotify(const IpStatNotify& from);

  inline IpStatNotify& operator=(const IpStatNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IpStatNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IpStatNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IpStatNotify* other);

  // implements Message ----------------------------------------------

  IpStatNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IpStatNotify& from);
  void MergeFrom(const IpStatNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 startTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 starttime() const;
  inline void set_starttime(::google::protobuf::uint64 value);

  // required uint64 endTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 endtime() const;
  inline void set_endtime(::google::protobuf::uint64 value);

  // optional uint32 pktNum = 3;
  inline bool has_pktnum() const;
  inline void clear_pktnum();
  static const int kPktNumFieldNumber = 3;
  inline ::google::protobuf::uint32 pktnum() const;
  inline void set_pktnum(::google::protobuf::uint32 value);

  // optional uint32 bytes = 4;
  inline bool has_bytes() const;
  inline void clear_bytes();
  static const int kBytesFieldNumber = 4;
  inline ::google::protobuf::uint32 bytes() const;
  inline void set_bytes(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.zte.netanalysis.capcontrol.IpStatNotify)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_pktnum();
  inline void clear_has_pktnum();
  inline void set_has_bytes();
  inline void clear_has_bytes();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 starttime_;
  ::google::protobuf::uint64 endtime_;
  ::google::protobuf::uint32 pktnum_;
  ::google::protobuf::uint32 bytes_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static IpStatNotify* default_instance_;
};
// -------------------------------------------------------------------

class TcpStatNotify_DirStat : public ::google::protobuf::MessageLite {
 public:
  TcpStatNotify_DirStat();
  virtual ~TcpStatNotify_DirStat();

  TcpStatNotify_DirStat(const TcpStatNotify_DirStat& from);

  inline TcpStatNotify_DirStat& operator=(const TcpStatNotify_DirStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TcpStatNotify_DirStat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TcpStatNotify_DirStat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TcpStatNotify_DirStat* other);

  // implements Message ----------------------------------------------

  TcpStatNotify_DirStat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TcpStatNotify_DirStat& from);
  void MergeFrom(const TcpStatNotify_DirStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 pktNum = 1;
  inline bool has_pktnum() const;
  inline void clear_pktnum();
  static const int kPktNumFieldNumber = 1;
  inline ::google::protobuf::uint32 pktnum() const;
  inline void set_pktnum(::google::protobuf::uint32 value);

  // optional uint32 bytes = 2;
  inline bool has_bytes() const;
  inline void clear_bytes();
  static const int kBytesFieldNumber = 2;
  inline ::google::protobuf::uint32 bytes() const;
  inline void set_bytes(::google::protobuf::uint32 value);

  // optional uint32 retransNum = 3;
  inline bool has_retransnum() const;
  inline void clear_retransnum();
  static const int kRetransNumFieldNumber = 3;
  inline ::google::protobuf::uint32 retransnum() const;
  inline void set_retransnum(::google::protobuf::uint32 value);

  // optional uint32 retransBytes = 4;
  inline bool has_retransbytes() const;
  inline void clear_retransbytes();
  static const int kRetransBytesFieldNumber = 4;
  inline ::google::protobuf::uint32 retransbytes() const;
  inline void set_retransbytes(::google::protobuf::uint32 value);

  // optional uint32 retransAckedNum = 5;
  inline bool has_retransackednum() const;
  inline void clear_retransackednum();
  static const int kRetransAckedNumFieldNumber = 5;
  inline ::google::protobuf::uint32 retransackednum() const;
  inline void set_retransackednum(::google::protobuf::uint32 value);

  // optional uint32 retransAckedBytes = 6;
  inline bool has_retransackedbytes() const;
  inline void clear_retransackedbytes();
  static const int kRetransAckedBytesFieldNumber = 6;
  inline ::google::protobuf::uint32 retransackedbytes() const;
  inline void set_retransackedbytes(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat)
 private:
  inline void set_has_pktnum();
  inline void clear_has_pktnum();
  inline void set_has_bytes();
  inline void clear_has_bytes();
  inline void set_has_retransnum();
  inline void clear_has_retransnum();
  inline void set_has_retransbytes();
  inline void clear_has_retransbytes();
  inline void set_has_retransackednum();
  inline void clear_has_retransackednum();
  inline void set_has_retransackedbytes();
  inline void clear_has_retransackedbytes();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 pktnum_;
  ::google::protobuf::uint32 bytes_;
  ::google::protobuf::uint32 retransnum_;
  ::google::protobuf::uint32 retransbytes_;
  ::google::protobuf::uint32 retransackednum_;
  ::google::protobuf::uint32 retransackedbytes_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static TcpStatNotify_DirStat* default_instance_;
};
// -------------------------------------------------------------------

class TcpStatNotify : public ::google::protobuf::MessageLite {
 public:
  TcpStatNotify();
  virtual ~TcpStatNotify();

  TcpStatNotify(const TcpStatNotify& from);

  inline TcpStatNotify& operator=(const TcpStatNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TcpStatNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TcpStatNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TcpStatNotify* other);

  // implements Message ----------------------------------------------

  TcpStatNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TcpStatNotify& from);
  void MergeFrom(const TcpStatNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TcpStatNotify_DirStat DirStat;

  // accessors -------------------------------------------------------

  // required uint64 startTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 starttime() const;
  inline void set_starttime(::google::protobuf::uint64 value);

  // required uint64 endTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 endtime() const;
  inline void set_endtime(::google::protobuf::uint64 value);

  // required uint32 sessionId = 3;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 sessionid() const;
  inline void set_sessionid(::google::protobuf::uint32 value);

  // optional .com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat dlStat = 4;
  inline bool has_dlstat() const;
  inline void clear_dlstat();
  static const int kDlStatFieldNumber = 4;
  inline const ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat& dlstat() const;
  inline ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat* mutable_dlstat();
  inline ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat* release_dlstat();
  inline void set_allocated_dlstat(::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat* dlstat);

  // optional .com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat ulStat = 5;
  inline bool has_ulstat() const;
  inline void clear_ulstat();
  static const int kUlStatFieldNumber = 5;
  inline const ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat& ulstat() const;
  inline ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat* mutable_ulstat();
  inline ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat* release_ulstat();
  inline void set_allocated_ulstat(::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat* ulstat);

  // @@protoc_insertion_point(class_scope:com.zte.netanalysis.capcontrol.TcpStatNotify)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_dlstat();
  inline void clear_has_dlstat();
  inline void set_has_ulstat();
  inline void clear_has_ulstat();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 starttime_;
  ::google::protobuf::uint64 endtime_;
  ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat* dlstat_;
  ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat* ulstat_;
  ::google::protobuf::uint32 sessionid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static TcpStatNotify* default_instance_;
};
// -------------------------------------------------------------------

class TcpSessionNotify_IpPort : public ::google::protobuf::MessageLite {
 public:
  TcpSessionNotify_IpPort();
  virtual ~TcpSessionNotify_IpPort();

  TcpSessionNotify_IpPort(const TcpSessionNotify_IpPort& from);

  inline TcpSessionNotify_IpPort& operator=(const TcpSessionNotify_IpPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TcpSessionNotify_IpPort& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TcpSessionNotify_IpPort* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TcpSessionNotify_IpPort* other);

  // implements Message ----------------------------------------------

  TcpSessionNotify_IpPort* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TcpSessionNotify_IpPort& from);
  void MergeFrom(const TcpSessionNotify_IpPort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string localIP = 1;
  inline bool has_localip() const;
  inline void clear_localip();
  static const int kLocalIPFieldNumber = 1;
  inline const ::std::string& localip() const;
  inline void set_localip(const ::std::string& value);
  inline void set_localip(const char* value);
  inline void set_localip(const char* value, size_t size);
  inline ::std::string* mutable_localip();
  inline ::std::string* release_localip();
  inline void set_allocated_localip(::std::string* localip);

  // required string remoteIP = 2;
  inline bool has_remoteip() const;
  inline void clear_remoteip();
  static const int kRemoteIPFieldNumber = 2;
  inline const ::std::string& remoteip() const;
  inline void set_remoteip(const ::std::string& value);
  inline void set_remoteip(const char* value);
  inline void set_remoteip(const char* value, size_t size);
  inline ::std::string* mutable_remoteip();
  inline ::std::string* release_remoteip();
  inline void set_allocated_remoteip(::std::string* remoteip);

  // required uint32 localPort = 3;
  inline bool has_localport() const;
  inline void clear_localport();
  static const int kLocalPortFieldNumber = 3;
  inline ::google::protobuf::uint32 localport() const;
  inline void set_localport(::google::protobuf::uint32 value);

  // required uint32 remotePort = 4;
  inline bool has_remoteport() const;
  inline void clear_remoteport();
  static const int kRemotePortFieldNumber = 4;
  inline ::google::protobuf::uint32 remoteport() const;
  inline void set_remoteport(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort)
 private:
  inline void set_has_localip();
  inline void clear_has_localip();
  inline void set_has_remoteip();
  inline void clear_has_remoteip();
  inline void set_has_localport();
  inline void clear_has_localport();
  inline void set_has_remoteport();
  inline void clear_has_remoteport();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* localip_;
  ::std::string* remoteip_;
  ::google::protobuf::uint32 localport_;
  ::google::protobuf::uint32 remoteport_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static TcpSessionNotify_IpPort* default_instance_;
};
// -------------------------------------------------------------------

class TcpSessionNotify_FlowInfo : public ::google::protobuf::MessageLite {
 public:
  TcpSessionNotify_FlowInfo();
  virtual ~TcpSessionNotify_FlowInfo();

  TcpSessionNotify_FlowInfo(const TcpSessionNotify_FlowInfo& from);

  inline TcpSessionNotify_FlowInfo& operator=(const TcpSessionNotify_FlowInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TcpSessionNotify_FlowInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TcpSessionNotify_FlowInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TcpSessionNotify_FlowInfo* other);

  // implements Message ----------------------------------------------

  TcpSessionNotify_FlowInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TcpSessionNotify_FlowInfo& from);
  void MergeFrom(const TcpSessionNotify_FlowInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 beginTime = 1;
  inline bool has_begintime() const;
  inline void clear_begintime();
  static const int kBeginTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 begintime() const;
  inline void set_begintime(::google::protobuf::uint64 value);

  // optional uint64 endTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 endtime() const;
  inline void set_endtime(::google::protobuf::uint64 value);

  // optional uint64 firstPayloadTime = 3;
  inline bool has_firstpayloadtime() const;
  inline void clear_firstpayloadtime();
  static const int kFirstPayloadTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 firstpayloadtime() const;
  inline void set_firstpayloadtime(::google::protobuf::uint64 value);

  // optional uint64 lastPayloadTime = 4;
  inline bool has_lastpayloadtime() const;
  inline void clear_lastpayloadtime();
  static const int kLastPayloadTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 lastpayloadtime() const;
  inline void set_lastpayloadtime(::google::protobuf::uint64 value);

  // optional uint32 totalPktNum = 5;
  inline bool has_totalpktnum() const;
  inline void clear_totalpktnum();
  static const int kTotalPktNumFieldNumber = 5;
  inline ::google::protobuf::uint32 totalpktnum() const;
  inline void set_totalpktnum(::google::protobuf::uint32 value);

  // optional uint32 totalBytes = 6;
  inline bool has_totalbytes() const;
  inline void clear_totalbytes();
  static const int kTotalBytesFieldNumber = 6;
  inline ::google::protobuf::uint32 totalbytes() const;
  inline void set_totalbytes(::google::protobuf::uint32 value);

  // optional uint32 retransPktNum = 7;
  inline bool has_retranspktnum() const;
  inline void clear_retranspktnum();
  static const int kRetransPktNumFieldNumber = 7;
  inline ::google::protobuf::uint32 retranspktnum() const;
  inline void set_retranspktnum(::google::protobuf::uint32 value);

  // optional uint32 retransBytes = 8;
  inline bool has_retransbytes() const;
  inline void clear_retransbytes();
  static const int kRetransBytesFieldNumber = 8;
  inline ::google::protobuf::uint32 retransbytes() const;
  inline void set_retransbytes(::google::protobuf::uint32 value);

  // optional uint32 retransAckedNum = 9;
  inline bool has_retransackednum() const;
  inline void clear_retransackednum();
  static const int kRetransAckedNumFieldNumber = 9;
  inline ::google::protobuf::uint32 retransackednum() const;
  inline void set_retransackednum(::google::protobuf::uint32 value);

  // optional uint32 retransAckedBytes = 10;
  inline bool has_retransackedbytes() const;
  inline void clear_retransackedbytes();
  static const int kRetransAckedBytesFieldNumber = 10;
  inline ::google::protobuf::uint32 retransackedbytes() const;
  inline void set_retransackedbytes(::google::protobuf::uint32 value);

  // optional uint32 fastRetransNum = 11;
  inline bool has_fastretransnum() const;
  inline void clear_fastretransnum();
  static const int kFastRetransNumFieldNumber = 11;
  inline ::google::protobuf::uint32 fastretransnum() const;
  inline void set_fastretransnum(::google::protobuf::uint32 value);

  // optional uint32 fastRetransBytes = 12;
  inline bool has_fastretransbytes() const;
  inline void clear_fastretransbytes();
  static const int kFastRetransBytesFieldNumber = 12;
  inline ::google::protobuf::uint32 fastretransbytes() const;
  inline void set_fastretransbytes(::google::protobuf::uint32 value);

  // optional uint32 disorderPktNum = 13;
  inline bool has_disorderpktnum() const;
  inline void clear_disorderpktnum();
  static const int kDisorderPktNumFieldNumber = 13;
  inline ::google::protobuf::uint32 disorderpktnum() const;
  inline void set_disorderpktnum(::google::protobuf::uint32 value);

  // optional uint32 disorderBytes = 14;
  inline bool has_disorderbytes() const;
  inline void clear_disorderbytes();
  static const int kDisorderBytesFieldNumber = 14;
  inline ::google::protobuf::uint32 disorderbytes() const;
  inline void set_disorderbytes(::google::protobuf::uint32 value);

  // optional uint32 dupAckNum = 15;
  inline bool has_dupacknum() const;
  inline void clear_dupacknum();
  static const int kDupAckNumFieldNumber = 15;
  inline ::google::protobuf::uint32 dupacknum() const;
  inline void set_dupacknum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo)
 private:
  inline void set_has_begintime();
  inline void clear_has_begintime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_firstpayloadtime();
  inline void clear_has_firstpayloadtime();
  inline void set_has_lastpayloadtime();
  inline void clear_has_lastpayloadtime();
  inline void set_has_totalpktnum();
  inline void clear_has_totalpktnum();
  inline void set_has_totalbytes();
  inline void clear_has_totalbytes();
  inline void set_has_retranspktnum();
  inline void clear_has_retranspktnum();
  inline void set_has_retransbytes();
  inline void clear_has_retransbytes();
  inline void set_has_retransackednum();
  inline void clear_has_retransackednum();
  inline void set_has_retransackedbytes();
  inline void clear_has_retransackedbytes();
  inline void set_has_fastretransnum();
  inline void clear_has_fastretransnum();
  inline void set_has_fastretransbytes();
  inline void clear_has_fastretransbytes();
  inline void set_has_disorderpktnum();
  inline void clear_has_disorderpktnum();
  inline void set_has_disorderbytes();
  inline void clear_has_disorderbytes();
  inline void set_has_dupacknum();
  inline void clear_has_dupacknum();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 begintime_;
  ::google::protobuf::uint64 endtime_;
  ::google::protobuf::uint64 firstpayloadtime_;
  ::google::protobuf::uint64 lastpayloadtime_;
  ::google::protobuf::uint32 totalpktnum_;
  ::google::protobuf::uint32 totalbytes_;
  ::google::protobuf::uint32 retranspktnum_;
  ::google::protobuf::uint32 retransbytes_;
  ::google::protobuf::uint32 retransackednum_;
  ::google::protobuf::uint32 retransackedbytes_;
  ::google::protobuf::uint32 fastretransnum_;
  ::google::protobuf::uint32 fastretransbytes_;
  ::google::protobuf::uint32 disorderpktnum_;
  ::google::protobuf::uint32 disorderbytes_;
  ::google::protobuf::uint32 dupacknum_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static TcpSessionNotify_FlowInfo* default_instance_;
};
// -------------------------------------------------------------------

class TcpSessionNotify : public ::google::protobuf::MessageLite {
 public:
  TcpSessionNotify();
  virtual ~TcpSessionNotify();

  TcpSessionNotify(const TcpSessionNotify& from);

  inline TcpSessionNotify& operator=(const TcpSessionNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TcpSessionNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TcpSessionNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TcpSessionNotify* other);

  // implements Message ----------------------------------------------

  TcpSessionNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TcpSessionNotify& from);
  void MergeFrom(const TcpSessionNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TcpSessionNotify_IpPort IpPort;
  typedef TcpSessionNotify_FlowInfo FlowInfo;

  // accessors -------------------------------------------------------

  // required uint32 sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 sessionid() const;
  inline void set_sessionid(::google::protobuf::uint32 value);

  // optional group IpPort = 2 {
  inline bool has_ipport() const;
  inline void clear_ipport();
  static const int kIpportFieldNumber = 2;
  inline const ::com::zte::netanalysis::capcontrol::TcpSessionNotify_IpPort& ipport() const;
  inline ::com::zte::netanalysis::capcontrol::TcpSessionNotify_IpPort* mutable_ipport();
  inline ::com::zte::netanalysis::capcontrol::TcpSessionNotify_IpPort* release_ipport();
  inline void set_allocated_ipport(::com::zte::netanalysis::capcontrol::TcpSessionNotify_IpPort* ipport);

  // optional uint32 rtt = 3;
  inline bool has_rtt() const;
  inline void clear_rtt();
  static const int kRttFieldNumber = 3;
  inline ::google::protobuf::uint32 rtt() const;
  inline void set_rtt(::google::protobuf::uint32 value);

  // optional .com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo dlInfo = 4;
  inline bool has_dlinfo() const;
  inline void clear_dlinfo();
  static const int kDlInfoFieldNumber = 4;
  inline const ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo& dlinfo() const;
  inline ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo* mutable_dlinfo();
  inline ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo* release_dlinfo();
  inline void set_allocated_dlinfo(::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo* dlinfo);

  // optional .com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo ulInfo = 5;
  inline bool has_ulinfo() const;
  inline void clear_ulinfo();
  static const int kUlInfoFieldNumber = 5;
  inline const ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo& ulinfo() const;
  inline ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo* mutable_ulinfo();
  inline ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo* release_ulinfo();
  inline void set_allocated_ulinfo(::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo* ulinfo);

  // @@protoc_insertion_point(class_scope:com.zte.netanalysis.capcontrol.TcpSessionNotify)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_ipport();
  inline void clear_has_ipport();
  inline void set_has_rtt();
  inline void clear_has_rtt();
  inline void set_has_dlinfo();
  inline void clear_has_dlinfo();
  inline void set_has_ulinfo();
  inline void clear_has_ulinfo();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::zte::netanalysis::capcontrol::TcpSessionNotify_IpPort* ipport_;
  ::google::protobuf::uint32 sessionid_;
  ::google::protobuf::uint32 rtt_;
  ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo* dlinfo_;
  ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo* ulinfo_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static TcpSessionNotify* default_instance_;
};
// -------------------------------------------------------------------

class DnsTransNotify : public ::google::protobuf::MessageLite {
 public:
  DnsTransNotify();
  virtual ~DnsTransNotify();

  DnsTransNotify(const DnsTransNotify& from);

  inline DnsTransNotify& operator=(const DnsTransNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DnsTransNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DnsTransNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DnsTransNotify* other);

  // implements Message ----------------------------------------------

  DnsTransNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DnsTransNotify& from);
  void MergeFrom(const DnsTransNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 retryCount = 1;
  inline bool has_retrycount() const;
  inline void clear_retrycount();
  static const int kRetryCountFieldNumber = 1;
  inline ::google::protobuf::uint32 retrycount() const;
  inline void set_retrycount(::google::protobuf::uint32 value);

  // optional uint64 queryTime = 2;
  inline bool has_querytime() const;
  inline void clear_querytime();
  static const int kQueryTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 querytime() const;
  inline void set_querytime(::google::protobuf::uint64 value);

  // optional uint64 answerTime = 3;
  inline bool has_answertime() const;
  inline void clear_answertime();
  static const int kAnswerTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 answertime() const;
  inline void set_answertime(::google::protobuf::uint64 value);

  // optional string dnsServerIp = 4;
  inline bool has_dnsserverip() const;
  inline void clear_dnsserverip();
  static const int kDnsServerIpFieldNumber = 4;
  inline const ::std::string& dnsserverip() const;
  inline void set_dnsserverip(const ::std::string& value);
  inline void set_dnsserverip(const char* value);
  inline void set_dnsserverip(const char* value, size_t size);
  inline ::std::string* mutable_dnsserverip();
  inline ::std::string* release_dnsserverip();
  inline void set_allocated_dnsserverip(::std::string* dnsserverip);

  // optional string hostName = 5;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostNameFieldNumber = 5;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string ipAddr = 6;
  inline bool has_ipaddr() const;
  inline void clear_ipaddr();
  static const int kIpAddrFieldNumber = 6;
  inline const ::std::string& ipaddr() const;
  inline void set_ipaddr(const ::std::string& value);
  inline void set_ipaddr(const char* value);
  inline void set_ipaddr(const char* value, size_t size);
  inline ::std::string* mutable_ipaddr();
  inline ::std::string* release_ipaddr();
  inline void set_allocated_ipaddr(::std::string* ipaddr);

  // @@protoc_insertion_point(class_scope:com.zte.netanalysis.capcontrol.DnsTransNotify)
 private:
  inline void set_has_retrycount();
  inline void clear_has_retrycount();
  inline void set_has_querytime();
  inline void clear_has_querytime();
  inline void set_has_answertime();
  inline void clear_has_answertime();
  inline void set_has_dnsserverip();
  inline void clear_has_dnsserverip();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_ipaddr();
  inline void clear_has_ipaddr();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 querytime_;
  ::google::protobuf::uint64 answertime_;
  ::std::string* dnsserverip_;
  ::std::string* hostname_;
  ::std::string* ipaddr_;
  ::google::protobuf::uint32 retrycount_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static DnsTransNotify* default_instance_;
};
// ===================================================================


// ===================================================================

// StartCapReq

// required int32 seq = 1;
inline bool StartCapReq::has_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartCapReq::set_has_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartCapReq::clear_has_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartCapReq::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 StartCapReq::seq() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.StartCapReq.seq)
  return seq_;
}
inline void StartCapReq::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.StartCapReq.seq)
}

// optional string url = 2;
inline bool StartCapReq::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartCapReq::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartCapReq::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartCapReq::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& StartCapReq::url() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.StartCapReq.url)
  return *url_;
}
inline void StartCapReq::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.StartCapReq.url)
}
inline void StartCapReq::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zte.netanalysis.capcontrol.StartCapReq.url)
}
inline void StartCapReq::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zte.netanalysis.capcontrol.StartCapReq.url)
}
inline ::std::string* StartCapReq::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zte.netanalysis.capcontrol.StartCapReq.url)
  return url_;
}
inline ::std::string* StartCapReq::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartCapReq::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zte.netanalysis.capcontrol.StartCapReq.url)
}

// optional string saveFile = 3;
inline bool StartCapReq::has_savefile() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartCapReq::set_has_savefile() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartCapReq::clear_has_savefile() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartCapReq::clear_savefile() {
  if (savefile_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    savefile_->clear();
  }
  clear_has_savefile();
}
inline const ::std::string& StartCapReq::savefile() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.StartCapReq.saveFile)
  return *savefile_;
}
inline void StartCapReq::set_savefile(const ::std::string& value) {
  set_has_savefile();
  if (savefile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    savefile_ = new ::std::string;
  }
  savefile_->assign(value);
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.StartCapReq.saveFile)
}
inline void StartCapReq::set_savefile(const char* value) {
  set_has_savefile();
  if (savefile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    savefile_ = new ::std::string;
  }
  savefile_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zte.netanalysis.capcontrol.StartCapReq.saveFile)
}
inline void StartCapReq::set_savefile(const char* value, size_t size) {
  set_has_savefile();
  if (savefile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    savefile_ = new ::std::string;
  }
  savefile_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zte.netanalysis.capcontrol.StartCapReq.saveFile)
}
inline ::std::string* StartCapReq::mutable_savefile() {
  set_has_savefile();
  if (savefile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    savefile_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zte.netanalysis.capcontrol.StartCapReq.saveFile)
  return savefile_;
}
inline ::std::string* StartCapReq::release_savefile() {
  clear_has_savefile();
  if (savefile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = savefile_;
    savefile_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartCapReq::set_allocated_savefile(::std::string* savefile) {
  if (savefile_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete savefile_;
  }
  if (savefile) {
    set_has_savefile();
    savefile_ = savefile;
  } else {
    clear_has_savefile();
    savefile_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zte.netanalysis.capcontrol.StartCapReq.saveFile)
}

// optional uint32 tcpStatInterval = 4;
inline bool StartCapReq::has_tcpstatinterval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartCapReq::set_has_tcpstatinterval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartCapReq::clear_has_tcpstatinterval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartCapReq::clear_tcpstatinterval() {
  tcpstatinterval_ = 0u;
  clear_has_tcpstatinterval();
}
inline ::google::protobuf::uint32 StartCapReq::tcpstatinterval() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.StartCapReq.tcpStatInterval)
  return tcpstatinterval_;
}
inline void StartCapReq::set_tcpstatinterval(::google::protobuf::uint32 value) {
  set_has_tcpstatinterval();
  tcpstatinterval_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.StartCapReq.tcpStatInterval)
}

// -------------------------------------------------------------------

// StartCapRes

// required int32 seq = 1;
inline bool StartCapRes::has_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartCapRes::set_has_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartCapRes::clear_has_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartCapRes::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 StartCapRes::seq() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.StartCapRes.seq)
  return seq_;
}
inline void StartCapRes::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.StartCapRes.seq)
}

// required int32 ack = 2;
inline bool StartCapRes::has_ack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartCapRes::set_has_ack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartCapRes::clear_has_ack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartCapRes::clear_ack() {
  ack_ = 0;
  clear_has_ack();
}
inline ::google::protobuf::int32 StartCapRes::ack() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.StartCapRes.ack)
  return ack_;
}
inline void StartCapRes::set_ack(::google::protobuf::int32 value) {
  set_has_ack();
  ack_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.StartCapRes.ack)
}

// required uint64 time = 3;
inline bool StartCapRes::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartCapRes::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartCapRes::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartCapRes::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 StartCapRes::time() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.StartCapRes.time)
  return time_;
}
inline void StartCapRes::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.StartCapRes.time)
}

// -------------------------------------------------------------------

// StopCapReq

// required int32 seq = 1;
inline bool StopCapReq::has_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopCapReq::set_has_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopCapReq::clear_has_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopCapReq::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 StopCapReq::seq() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.StopCapReq.seq)
  return seq_;
}
inline void StopCapReq::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.StopCapReq.seq)
}

// -------------------------------------------------------------------

// StopCapRes

// required int32 seq = 1;
inline bool StopCapRes::has_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopCapRes::set_has_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopCapRes::clear_has_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopCapRes::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 StopCapRes::seq() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.StopCapRes.seq)
  return seq_;
}
inline void StopCapRes::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.StopCapRes.seq)
}

// required uint64 time = 2;
inline bool StopCapRes::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StopCapRes::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StopCapRes::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StopCapRes::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 StopCapRes::time() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.StopCapRes.time)
  return time_;
}
inline void StopCapRes::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.StopCapRes.time)
}

// optional uint32 totalSecs = 3;
inline bool StopCapRes::has_totalsecs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StopCapRes::set_has_totalsecs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StopCapRes::clear_has_totalsecs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StopCapRes::clear_totalsecs() {
  totalsecs_ = 0u;
  clear_has_totalsecs();
}
inline ::google::protobuf::uint32 StopCapRes::totalsecs() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.StopCapRes.totalSecs)
  return totalsecs_;
}
inline void StopCapRes::set_totalsecs(::google::protobuf::uint32 value) {
  set_has_totalsecs();
  totalsecs_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.StopCapRes.totalSecs)
}

// optional uint32 totalPktNum = 4;
inline bool StopCapRes::has_totalpktnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StopCapRes::set_has_totalpktnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StopCapRes::clear_has_totalpktnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StopCapRes::clear_totalpktnum() {
  totalpktnum_ = 0u;
  clear_has_totalpktnum();
}
inline ::google::protobuf::uint32 StopCapRes::totalpktnum() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.StopCapRes.totalPktNum)
  return totalpktnum_;
}
inline void StopCapRes::set_totalpktnum(::google::protobuf::uint32 value) {
  set_has_totalpktnum();
  totalpktnum_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.StopCapRes.totalPktNum)
}

// optional uint32 droppedPktNum = 5;
inline bool StopCapRes::has_droppedpktnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StopCapRes::set_has_droppedpktnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StopCapRes::clear_has_droppedpktnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StopCapRes::clear_droppedpktnum() {
  droppedpktnum_ = 0u;
  clear_has_droppedpktnum();
}
inline ::google::protobuf::uint32 StopCapRes::droppedpktnum() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.StopCapRes.droppedPktNum)
  return droppedpktnum_;
}
inline void StopCapRes::set_droppedpktnum(::google::protobuf::uint32 value) {
  set_has_droppedpktnum();
  droppedpktnum_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.StopCapRes.droppedPktNum)
}

// -------------------------------------------------------------------

// IpStatNotify

// required uint64 startTime = 1;
inline bool IpStatNotify::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpStatNotify::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IpStatNotify::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IpStatNotify::clear_starttime() {
  starttime_ = GOOGLE_ULONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::uint64 IpStatNotify::starttime() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.IpStatNotify.startTime)
  return starttime_;
}
inline void IpStatNotify::set_starttime(::google::protobuf::uint64 value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.IpStatNotify.startTime)
}

// required uint64 endTime = 2;
inline bool IpStatNotify::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpStatNotify::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IpStatNotify::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IpStatNotify::clear_endtime() {
  endtime_ = GOOGLE_ULONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::uint64 IpStatNotify::endtime() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.IpStatNotify.endTime)
  return endtime_;
}
inline void IpStatNotify::set_endtime(::google::protobuf::uint64 value) {
  set_has_endtime();
  endtime_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.IpStatNotify.endTime)
}

// optional uint32 pktNum = 3;
inline bool IpStatNotify::has_pktnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IpStatNotify::set_has_pktnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IpStatNotify::clear_has_pktnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IpStatNotify::clear_pktnum() {
  pktnum_ = 0u;
  clear_has_pktnum();
}
inline ::google::protobuf::uint32 IpStatNotify::pktnum() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.IpStatNotify.pktNum)
  return pktnum_;
}
inline void IpStatNotify::set_pktnum(::google::protobuf::uint32 value) {
  set_has_pktnum();
  pktnum_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.IpStatNotify.pktNum)
}

// optional uint32 bytes = 4;
inline bool IpStatNotify::has_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IpStatNotify::set_has_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IpStatNotify::clear_has_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IpStatNotify::clear_bytes() {
  bytes_ = 0u;
  clear_has_bytes();
}
inline ::google::protobuf::uint32 IpStatNotify::bytes() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.IpStatNotify.bytes)
  return bytes_;
}
inline void IpStatNotify::set_bytes(::google::protobuf::uint32 value) {
  set_has_bytes();
  bytes_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.IpStatNotify.bytes)
}

// -------------------------------------------------------------------

// TcpStatNotify_DirStat

// optional uint32 pktNum = 1;
inline bool TcpStatNotify_DirStat::has_pktnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TcpStatNotify_DirStat::set_has_pktnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TcpStatNotify_DirStat::clear_has_pktnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TcpStatNotify_DirStat::clear_pktnum() {
  pktnum_ = 0u;
  clear_has_pktnum();
}
inline ::google::protobuf::uint32 TcpStatNotify_DirStat::pktnum() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat.pktNum)
  return pktnum_;
}
inline void TcpStatNotify_DirStat::set_pktnum(::google::protobuf::uint32 value) {
  set_has_pktnum();
  pktnum_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat.pktNum)
}

// optional uint32 bytes = 2;
inline bool TcpStatNotify_DirStat::has_bytes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TcpStatNotify_DirStat::set_has_bytes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TcpStatNotify_DirStat::clear_has_bytes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TcpStatNotify_DirStat::clear_bytes() {
  bytes_ = 0u;
  clear_has_bytes();
}
inline ::google::protobuf::uint32 TcpStatNotify_DirStat::bytes() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat.bytes)
  return bytes_;
}
inline void TcpStatNotify_DirStat::set_bytes(::google::protobuf::uint32 value) {
  set_has_bytes();
  bytes_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat.bytes)
}

// optional uint32 retransNum = 3;
inline bool TcpStatNotify_DirStat::has_retransnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TcpStatNotify_DirStat::set_has_retransnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TcpStatNotify_DirStat::clear_has_retransnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TcpStatNotify_DirStat::clear_retransnum() {
  retransnum_ = 0u;
  clear_has_retransnum();
}
inline ::google::protobuf::uint32 TcpStatNotify_DirStat::retransnum() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat.retransNum)
  return retransnum_;
}
inline void TcpStatNotify_DirStat::set_retransnum(::google::protobuf::uint32 value) {
  set_has_retransnum();
  retransnum_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat.retransNum)
}

// optional uint32 retransBytes = 4;
inline bool TcpStatNotify_DirStat::has_retransbytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TcpStatNotify_DirStat::set_has_retransbytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TcpStatNotify_DirStat::clear_has_retransbytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TcpStatNotify_DirStat::clear_retransbytes() {
  retransbytes_ = 0u;
  clear_has_retransbytes();
}
inline ::google::protobuf::uint32 TcpStatNotify_DirStat::retransbytes() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat.retransBytes)
  return retransbytes_;
}
inline void TcpStatNotify_DirStat::set_retransbytes(::google::protobuf::uint32 value) {
  set_has_retransbytes();
  retransbytes_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat.retransBytes)
}

// optional uint32 retransAckedNum = 5;
inline bool TcpStatNotify_DirStat::has_retransackednum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TcpStatNotify_DirStat::set_has_retransackednum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TcpStatNotify_DirStat::clear_has_retransackednum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TcpStatNotify_DirStat::clear_retransackednum() {
  retransackednum_ = 0u;
  clear_has_retransackednum();
}
inline ::google::protobuf::uint32 TcpStatNotify_DirStat::retransackednum() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat.retransAckedNum)
  return retransackednum_;
}
inline void TcpStatNotify_DirStat::set_retransackednum(::google::protobuf::uint32 value) {
  set_has_retransackednum();
  retransackednum_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat.retransAckedNum)
}

// optional uint32 retransAckedBytes = 6;
inline bool TcpStatNotify_DirStat::has_retransackedbytes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TcpStatNotify_DirStat::set_has_retransackedbytes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TcpStatNotify_DirStat::clear_has_retransackedbytes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TcpStatNotify_DirStat::clear_retransackedbytes() {
  retransackedbytes_ = 0u;
  clear_has_retransackedbytes();
}
inline ::google::protobuf::uint32 TcpStatNotify_DirStat::retransackedbytes() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat.retransAckedBytes)
  return retransackedbytes_;
}
inline void TcpStatNotify_DirStat::set_retransackedbytes(::google::protobuf::uint32 value) {
  set_has_retransackedbytes();
  retransackedbytes_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat.retransAckedBytes)
}

// -------------------------------------------------------------------

// TcpStatNotify

// required uint64 startTime = 1;
inline bool TcpStatNotify::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TcpStatNotify::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TcpStatNotify::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TcpStatNotify::clear_starttime() {
  starttime_ = GOOGLE_ULONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::uint64 TcpStatNotify::starttime() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpStatNotify.startTime)
  return starttime_;
}
inline void TcpStatNotify::set_starttime(::google::protobuf::uint64 value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpStatNotify.startTime)
}

// required uint64 endTime = 2;
inline bool TcpStatNotify::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TcpStatNotify::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TcpStatNotify::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TcpStatNotify::clear_endtime() {
  endtime_ = GOOGLE_ULONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::uint64 TcpStatNotify::endtime() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpStatNotify.endTime)
  return endtime_;
}
inline void TcpStatNotify::set_endtime(::google::protobuf::uint64 value) {
  set_has_endtime();
  endtime_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpStatNotify.endTime)
}

// required uint32 sessionId = 3;
inline bool TcpStatNotify::has_sessionid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TcpStatNotify::set_has_sessionid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TcpStatNotify::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TcpStatNotify::clear_sessionid() {
  sessionid_ = 0u;
  clear_has_sessionid();
}
inline ::google::protobuf::uint32 TcpStatNotify::sessionid() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpStatNotify.sessionId)
  return sessionid_;
}
inline void TcpStatNotify::set_sessionid(::google::protobuf::uint32 value) {
  set_has_sessionid();
  sessionid_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpStatNotify.sessionId)
}

// optional .com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat dlStat = 4;
inline bool TcpStatNotify::has_dlstat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TcpStatNotify::set_has_dlstat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TcpStatNotify::clear_has_dlstat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TcpStatNotify::clear_dlstat() {
  if (dlstat_ != NULL) dlstat_->::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat::Clear();
  clear_has_dlstat();
}
inline const ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat& TcpStatNotify::dlstat() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpStatNotify.dlStat)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dlstat_ != NULL ? *dlstat_ : *default_instance().dlstat_;
#else
  return dlstat_ != NULL ? *dlstat_ : *default_instance_->dlstat_;
#endif
}
inline ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat* TcpStatNotify::mutable_dlstat() {
  set_has_dlstat();
  if (dlstat_ == NULL) dlstat_ = new ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat;
  // @@protoc_insertion_point(field_mutable:com.zte.netanalysis.capcontrol.TcpStatNotify.dlStat)
  return dlstat_;
}
inline ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat* TcpStatNotify::release_dlstat() {
  clear_has_dlstat();
  ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat* temp = dlstat_;
  dlstat_ = NULL;
  return temp;
}
inline void TcpStatNotify::set_allocated_dlstat(::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat* dlstat) {
  delete dlstat_;
  dlstat_ = dlstat;
  if (dlstat) {
    set_has_dlstat();
  } else {
    clear_has_dlstat();
  }
  // @@protoc_insertion_point(field_set_allocated:com.zte.netanalysis.capcontrol.TcpStatNotify.dlStat)
}

// optional .com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat ulStat = 5;
inline bool TcpStatNotify::has_ulstat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TcpStatNotify::set_has_ulstat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TcpStatNotify::clear_has_ulstat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TcpStatNotify::clear_ulstat() {
  if (ulstat_ != NULL) ulstat_->::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat::Clear();
  clear_has_ulstat();
}
inline const ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat& TcpStatNotify::ulstat() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpStatNotify.ulStat)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ulstat_ != NULL ? *ulstat_ : *default_instance().ulstat_;
#else
  return ulstat_ != NULL ? *ulstat_ : *default_instance_->ulstat_;
#endif
}
inline ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat* TcpStatNotify::mutable_ulstat() {
  set_has_ulstat();
  if (ulstat_ == NULL) ulstat_ = new ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat;
  // @@protoc_insertion_point(field_mutable:com.zte.netanalysis.capcontrol.TcpStatNotify.ulStat)
  return ulstat_;
}
inline ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat* TcpStatNotify::release_ulstat() {
  clear_has_ulstat();
  ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat* temp = ulstat_;
  ulstat_ = NULL;
  return temp;
}
inline void TcpStatNotify::set_allocated_ulstat(::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat* ulstat) {
  delete ulstat_;
  ulstat_ = ulstat;
  if (ulstat) {
    set_has_ulstat();
  } else {
    clear_has_ulstat();
  }
  // @@protoc_insertion_point(field_set_allocated:com.zte.netanalysis.capcontrol.TcpStatNotify.ulStat)
}

// -------------------------------------------------------------------

// TcpSessionNotify_IpPort

// required string localIP = 1;
inline bool TcpSessionNotify_IpPort::has_localip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TcpSessionNotify_IpPort::set_has_localip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TcpSessionNotify_IpPort::clear_has_localip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TcpSessionNotify_IpPort::clear_localip() {
  if (localip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localip_->clear();
  }
  clear_has_localip();
}
inline const ::std::string& TcpSessionNotify_IpPort::localip() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort.localIP)
  return *localip_;
}
inline void TcpSessionNotify_IpPort::set_localip(const ::std::string& value) {
  set_has_localip();
  if (localip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localip_ = new ::std::string;
  }
  localip_->assign(value);
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort.localIP)
}
inline void TcpSessionNotify_IpPort::set_localip(const char* value) {
  set_has_localip();
  if (localip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localip_ = new ::std::string;
  }
  localip_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort.localIP)
}
inline void TcpSessionNotify_IpPort::set_localip(const char* value, size_t size) {
  set_has_localip();
  if (localip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localip_ = new ::std::string;
  }
  localip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort.localIP)
}
inline ::std::string* TcpSessionNotify_IpPort::mutable_localip() {
  set_has_localip();
  if (localip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort.localIP)
  return localip_;
}
inline ::std::string* TcpSessionNotify_IpPort::release_localip() {
  clear_has_localip();
  if (localip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = localip_;
    localip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TcpSessionNotify_IpPort::set_allocated_localip(::std::string* localip) {
  if (localip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete localip_;
  }
  if (localip) {
    set_has_localip();
    localip_ = localip;
  } else {
    clear_has_localip();
    localip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort.localIP)
}

// required string remoteIP = 2;
inline bool TcpSessionNotify_IpPort::has_remoteip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TcpSessionNotify_IpPort::set_has_remoteip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TcpSessionNotify_IpPort::clear_has_remoteip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TcpSessionNotify_IpPort::clear_remoteip() {
  if (remoteip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remoteip_->clear();
  }
  clear_has_remoteip();
}
inline const ::std::string& TcpSessionNotify_IpPort::remoteip() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort.remoteIP)
  return *remoteip_;
}
inline void TcpSessionNotify_IpPort::set_remoteip(const ::std::string& value) {
  set_has_remoteip();
  if (remoteip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remoteip_ = new ::std::string;
  }
  remoteip_->assign(value);
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort.remoteIP)
}
inline void TcpSessionNotify_IpPort::set_remoteip(const char* value) {
  set_has_remoteip();
  if (remoteip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remoteip_ = new ::std::string;
  }
  remoteip_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort.remoteIP)
}
inline void TcpSessionNotify_IpPort::set_remoteip(const char* value, size_t size) {
  set_has_remoteip();
  if (remoteip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remoteip_ = new ::std::string;
  }
  remoteip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort.remoteIP)
}
inline ::std::string* TcpSessionNotify_IpPort::mutable_remoteip() {
  set_has_remoteip();
  if (remoteip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remoteip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort.remoteIP)
  return remoteip_;
}
inline ::std::string* TcpSessionNotify_IpPort::release_remoteip() {
  clear_has_remoteip();
  if (remoteip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remoteip_;
    remoteip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TcpSessionNotify_IpPort::set_allocated_remoteip(::std::string* remoteip) {
  if (remoteip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remoteip_;
  }
  if (remoteip) {
    set_has_remoteip();
    remoteip_ = remoteip;
  } else {
    clear_has_remoteip();
    remoteip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort.remoteIP)
}

// required uint32 localPort = 3;
inline bool TcpSessionNotify_IpPort::has_localport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TcpSessionNotify_IpPort::set_has_localport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TcpSessionNotify_IpPort::clear_has_localport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TcpSessionNotify_IpPort::clear_localport() {
  localport_ = 0u;
  clear_has_localport();
}
inline ::google::protobuf::uint32 TcpSessionNotify_IpPort::localport() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort.localPort)
  return localport_;
}
inline void TcpSessionNotify_IpPort::set_localport(::google::protobuf::uint32 value) {
  set_has_localport();
  localport_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort.localPort)
}

// required uint32 remotePort = 4;
inline bool TcpSessionNotify_IpPort::has_remoteport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TcpSessionNotify_IpPort::set_has_remoteport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TcpSessionNotify_IpPort::clear_has_remoteport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TcpSessionNotify_IpPort::clear_remoteport() {
  remoteport_ = 0u;
  clear_has_remoteport();
}
inline ::google::protobuf::uint32 TcpSessionNotify_IpPort::remoteport() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort.remotePort)
  return remoteport_;
}
inline void TcpSessionNotify_IpPort::set_remoteport(::google::protobuf::uint32 value) {
  set_has_remoteport();
  remoteport_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort.remotePort)
}

// -------------------------------------------------------------------

// TcpSessionNotify_FlowInfo

// optional uint64 beginTime = 1;
inline bool TcpSessionNotify_FlowInfo::has_begintime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TcpSessionNotify_FlowInfo::set_has_begintime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TcpSessionNotify_FlowInfo::clear_has_begintime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TcpSessionNotify_FlowInfo::clear_begintime() {
  begintime_ = GOOGLE_ULONGLONG(0);
  clear_has_begintime();
}
inline ::google::protobuf::uint64 TcpSessionNotify_FlowInfo::begintime() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.beginTime)
  return begintime_;
}
inline void TcpSessionNotify_FlowInfo::set_begintime(::google::protobuf::uint64 value) {
  set_has_begintime();
  begintime_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.beginTime)
}

// optional uint64 endTime = 2;
inline bool TcpSessionNotify_FlowInfo::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TcpSessionNotify_FlowInfo::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TcpSessionNotify_FlowInfo::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TcpSessionNotify_FlowInfo::clear_endtime() {
  endtime_ = GOOGLE_ULONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::uint64 TcpSessionNotify_FlowInfo::endtime() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.endTime)
  return endtime_;
}
inline void TcpSessionNotify_FlowInfo::set_endtime(::google::protobuf::uint64 value) {
  set_has_endtime();
  endtime_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.endTime)
}

// optional uint64 firstPayloadTime = 3;
inline bool TcpSessionNotify_FlowInfo::has_firstpayloadtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TcpSessionNotify_FlowInfo::set_has_firstpayloadtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TcpSessionNotify_FlowInfo::clear_has_firstpayloadtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TcpSessionNotify_FlowInfo::clear_firstpayloadtime() {
  firstpayloadtime_ = GOOGLE_ULONGLONG(0);
  clear_has_firstpayloadtime();
}
inline ::google::protobuf::uint64 TcpSessionNotify_FlowInfo::firstpayloadtime() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.firstPayloadTime)
  return firstpayloadtime_;
}
inline void TcpSessionNotify_FlowInfo::set_firstpayloadtime(::google::protobuf::uint64 value) {
  set_has_firstpayloadtime();
  firstpayloadtime_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.firstPayloadTime)
}

// optional uint64 lastPayloadTime = 4;
inline bool TcpSessionNotify_FlowInfo::has_lastpayloadtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TcpSessionNotify_FlowInfo::set_has_lastpayloadtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TcpSessionNotify_FlowInfo::clear_has_lastpayloadtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TcpSessionNotify_FlowInfo::clear_lastpayloadtime() {
  lastpayloadtime_ = GOOGLE_ULONGLONG(0);
  clear_has_lastpayloadtime();
}
inline ::google::protobuf::uint64 TcpSessionNotify_FlowInfo::lastpayloadtime() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.lastPayloadTime)
  return lastpayloadtime_;
}
inline void TcpSessionNotify_FlowInfo::set_lastpayloadtime(::google::protobuf::uint64 value) {
  set_has_lastpayloadtime();
  lastpayloadtime_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.lastPayloadTime)
}

// optional uint32 totalPktNum = 5;
inline bool TcpSessionNotify_FlowInfo::has_totalpktnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TcpSessionNotify_FlowInfo::set_has_totalpktnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TcpSessionNotify_FlowInfo::clear_has_totalpktnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TcpSessionNotify_FlowInfo::clear_totalpktnum() {
  totalpktnum_ = 0u;
  clear_has_totalpktnum();
}
inline ::google::protobuf::uint32 TcpSessionNotify_FlowInfo::totalpktnum() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.totalPktNum)
  return totalpktnum_;
}
inline void TcpSessionNotify_FlowInfo::set_totalpktnum(::google::protobuf::uint32 value) {
  set_has_totalpktnum();
  totalpktnum_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.totalPktNum)
}

// optional uint32 totalBytes = 6;
inline bool TcpSessionNotify_FlowInfo::has_totalbytes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TcpSessionNotify_FlowInfo::set_has_totalbytes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TcpSessionNotify_FlowInfo::clear_has_totalbytes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TcpSessionNotify_FlowInfo::clear_totalbytes() {
  totalbytes_ = 0u;
  clear_has_totalbytes();
}
inline ::google::protobuf::uint32 TcpSessionNotify_FlowInfo::totalbytes() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.totalBytes)
  return totalbytes_;
}
inline void TcpSessionNotify_FlowInfo::set_totalbytes(::google::protobuf::uint32 value) {
  set_has_totalbytes();
  totalbytes_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.totalBytes)
}

// optional uint32 retransPktNum = 7;
inline bool TcpSessionNotify_FlowInfo::has_retranspktnum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TcpSessionNotify_FlowInfo::set_has_retranspktnum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TcpSessionNotify_FlowInfo::clear_has_retranspktnum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TcpSessionNotify_FlowInfo::clear_retranspktnum() {
  retranspktnum_ = 0u;
  clear_has_retranspktnum();
}
inline ::google::protobuf::uint32 TcpSessionNotify_FlowInfo::retranspktnum() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.retransPktNum)
  return retranspktnum_;
}
inline void TcpSessionNotify_FlowInfo::set_retranspktnum(::google::protobuf::uint32 value) {
  set_has_retranspktnum();
  retranspktnum_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.retransPktNum)
}

// optional uint32 retransBytes = 8;
inline bool TcpSessionNotify_FlowInfo::has_retransbytes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TcpSessionNotify_FlowInfo::set_has_retransbytes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TcpSessionNotify_FlowInfo::clear_has_retransbytes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TcpSessionNotify_FlowInfo::clear_retransbytes() {
  retransbytes_ = 0u;
  clear_has_retransbytes();
}
inline ::google::protobuf::uint32 TcpSessionNotify_FlowInfo::retransbytes() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.retransBytes)
  return retransbytes_;
}
inline void TcpSessionNotify_FlowInfo::set_retransbytes(::google::protobuf::uint32 value) {
  set_has_retransbytes();
  retransbytes_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.retransBytes)
}

// optional uint32 retransAckedNum = 9;
inline bool TcpSessionNotify_FlowInfo::has_retransackednum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TcpSessionNotify_FlowInfo::set_has_retransackednum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TcpSessionNotify_FlowInfo::clear_has_retransackednum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TcpSessionNotify_FlowInfo::clear_retransackednum() {
  retransackednum_ = 0u;
  clear_has_retransackednum();
}
inline ::google::protobuf::uint32 TcpSessionNotify_FlowInfo::retransackednum() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.retransAckedNum)
  return retransackednum_;
}
inline void TcpSessionNotify_FlowInfo::set_retransackednum(::google::protobuf::uint32 value) {
  set_has_retransackednum();
  retransackednum_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.retransAckedNum)
}

// optional uint32 retransAckedBytes = 10;
inline bool TcpSessionNotify_FlowInfo::has_retransackedbytes() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TcpSessionNotify_FlowInfo::set_has_retransackedbytes() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TcpSessionNotify_FlowInfo::clear_has_retransackedbytes() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TcpSessionNotify_FlowInfo::clear_retransackedbytes() {
  retransackedbytes_ = 0u;
  clear_has_retransackedbytes();
}
inline ::google::protobuf::uint32 TcpSessionNotify_FlowInfo::retransackedbytes() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.retransAckedBytes)
  return retransackedbytes_;
}
inline void TcpSessionNotify_FlowInfo::set_retransackedbytes(::google::protobuf::uint32 value) {
  set_has_retransackedbytes();
  retransackedbytes_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.retransAckedBytes)
}

// optional uint32 fastRetransNum = 11;
inline bool TcpSessionNotify_FlowInfo::has_fastretransnum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TcpSessionNotify_FlowInfo::set_has_fastretransnum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TcpSessionNotify_FlowInfo::clear_has_fastretransnum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TcpSessionNotify_FlowInfo::clear_fastretransnum() {
  fastretransnum_ = 0u;
  clear_has_fastretransnum();
}
inline ::google::protobuf::uint32 TcpSessionNotify_FlowInfo::fastretransnum() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.fastRetransNum)
  return fastretransnum_;
}
inline void TcpSessionNotify_FlowInfo::set_fastretransnum(::google::protobuf::uint32 value) {
  set_has_fastretransnum();
  fastretransnum_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.fastRetransNum)
}

// optional uint32 fastRetransBytes = 12;
inline bool TcpSessionNotify_FlowInfo::has_fastretransbytes() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TcpSessionNotify_FlowInfo::set_has_fastretransbytes() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TcpSessionNotify_FlowInfo::clear_has_fastretransbytes() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TcpSessionNotify_FlowInfo::clear_fastretransbytes() {
  fastretransbytes_ = 0u;
  clear_has_fastretransbytes();
}
inline ::google::protobuf::uint32 TcpSessionNotify_FlowInfo::fastretransbytes() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.fastRetransBytes)
  return fastretransbytes_;
}
inline void TcpSessionNotify_FlowInfo::set_fastretransbytes(::google::protobuf::uint32 value) {
  set_has_fastretransbytes();
  fastretransbytes_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.fastRetransBytes)
}

// optional uint32 disorderPktNum = 13;
inline bool TcpSessionNotify_FlowInfo::has_disorderpktnum() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TcpSessionNotify_FlowInfo::set_has_disorderpktnum() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TcpSessionNotify_FlowInfo::clear_has_disorderpktnum() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TcpSessionNotify_FlowInfo::clear_disorderpktnum() {
  disorderpktnum_ = 0u;
  clear_has_disorderpktnum();
}
inline ::google::protobuf::uint32 TcpSessionNotify_FlowInfo::disorderpktnum() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.disorderPktNum)
  return disorderpktnum_;
}
inline void TcpSessionNotify_FlowInfo::set_disorderpktnum(::google::protobuf::uint32 value) {
  set_has_disorderpktnum();
  disorderpktnum_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.disorderPktNum)
}

// optional uint32 disorderBytes = 14;
inline bool TcpSessionNotify_FlowInfo::has_disorderbytes() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TcpSessionNotify_FlowInfo::set_has_disorderbytes() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TcpSessionNotify_FlowInfo::clear_has_disorderbytes() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TcpSessionNotify_FlowInfo::clear_disorderbytes() {
  disorderbytes_ = 0u;
  clear_has_disorderbytes();
}
inline ::google::protobuf::uint32 TcpSessionNotify_FlowInfo::disorderbytes() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.disorderBytes)
  return disorderbytes_;
}
inline void TcpSessionNotify_FlowInfo::set_disorderbytes(::google::protobuf::uint32 value) {
  set_has_disorderbytes();
  disorderbytes_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.disorderBytes)
}

// optional uint32 dupAckNum = 15;
inline bool TcpSessionNotify_FlowInfo::has_dupacknum() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TcpSessionNotify_FlowInfo::set_has_dupacknum() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TcpSessionNotify_FlowInfo::clear_has_dupacknum() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TcpSessionNotify_FlowInfo::clear_dupacknum() {
  dupacknum_ = 0u;
  clear_has_dupacknum();
}
inline ::google::protobuf::uint32 TcpSessionNotify_FlowInfo::dupacknum() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.dupAckNum)
  return dupacknum_;
}
inline void TcpSessionNotify_FlowInfo::set_dupacknum(::google::protobuf::uint32 value) {
  set_has_dupacknum();
  dupacknum_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo.dupAckNum)
}

// -------------------------------------------------------------------

// TcpSessionNotify

// required uint32 sessionId = 1;
inline bool TcpSessionNotify::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TcpSessionNotify::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TcpSessionNotify::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TcpSessionNotify::clear_sessionid() {
  sessionid_ = 0u;
  clear_has_sessionid();
}
inline ::google::protobuf::uint32 TcpSessionNotify::sessionid() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.sessionId)
  return sessionid_;
}
inline void TcpSessionNotify::set_sessionid(::google::protobuf::uint32 value) {
  set_has_sessionid();
  sessionid_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.sessionId)
}

// optional group IpPort = 2 {
inline bool TcpSessionNotify::has_ipport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TcpSessionNotify::set_has_ipport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TcpSessionNotify::clear_has_ipport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TcpSessionNotify::clear_ipport() {
  if (ipport_ != NULL) ipport_->::com::zte::netanalysis::capcontrol::TcpSessionNotify_IpPort::Clear();
  clear_has_ipport();
}
inline const ::com::zte::netanalysis::capcontrol::TcpSessionNotify_IpPort& TcpSessionNotify::ipport() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.ipport)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ipport_ != NULL ? *ipport_ : *default_instance().ipport_;
#else
  return ipport_ != NULL ? *ipport_ : *default_instance_->ipport_;
#endif
}
inline ::com::zte::netanalysis::capcontrol::TcpSessionNotify_IpPort* TcpSessionNotify::mutable_ipport() {
  set_has_ipport();
  if (ipport_ == NULL) ipport_ = new ::com::zte::netanalysis::capcontrol::TcpSessionNotify_IpPort;
  // @@protoc_insertion_point(field_mutable:com.zte.netanalysis.capcontrol.TcpSessionNotify.ipport)
  return ipport_;
}
inline ::com::zte::netanalysis::capcontrol::TcpSessionNotify_IpPort* TcpSessionNotify::release_ipport() {
  clear_has_ipport();
  ::com::zte::netanalysis::capcontrol::TcpSessionNotify_IpPort* temp = ipport_;
  ipport_ = NULL;
  return temp;
}
inline void TcpSessionNotify::set_allocated_ipport(::com::zte::netanalysis::capcontrol::TcpSessionNotify_IpPort* ipport) {
  delete ipport_;
  ipport_ = ipport;
  if (ipport) {
    set_has_ipport();
  } else {
    clear_has_ipport();
  }
  // @@protoc_insertion_point(field_set_allocated:com.zte.netanalysis.capcontrol.TcpSessionNotify.ipport)
}

// optional uint32 rtt = 3;
inline bool TcpSessionNotify::has_rtt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TcpSessionNotify::set_has_rtt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TcpSessionNotify::clear_has_rtt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TcpSessionNotify::clear_rtt() {
  rtt_ = 0u;
  clear_has_rtt();
}
inline ::google::protobuf::uint32 TcpSessionNotify::rtt() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.rtt)
  return rtt_;
}
inline void TcpSessionNotify::set_rtt(::google::protobuf::uint32 value) {
  set_has_rtt();
  rtt_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.TcpSessionNotify.rtt)
}

// optional .com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo dlInfo = 4;
inline bool TcpSessionNotify::has_dlinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TcpSessionNotify::set_has_dlinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TcpSessionNotify::clear_has_dlinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TcpSessionNotify::clear_dlinfo() {
  if (dlinfo_ != NULL) dlinfo_->::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo::Clear();
  clear_has_dlinfo();
}
inline const ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo& TcpSessionNotify::dlinfo() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.dlInfo)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dlinfo_ != NULL ? *dlinfo_ : *default_instance().dlinfo_;
#else
  return dlinfo_ != NULL ? *dlinfo_ : *default_instance_->dlinfo_;
#endif
}
inline ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo* TcpSessionNotify::mutable_dlinfo() {
  set_has_dlinfo();
  if (dlinfo_ == NULL) dlinfo_ = new ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo;
  // @@protoc_insertion_point(field_mutable:com.zte.netanalysis.capcontrol.TcpSessionNotify.dlInfo)
  return dlinfo_;
}
inline ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo* TcpSessionNotify::release_dlinfo() {
  clear_has_dlinfo();
  ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo* temp = dlinfo_;
  dlinfo_ = NULL;
  return temp;
}
inline void TcpSessionNotify::set_allocated_dlinfo(::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo* dlinfo) {
  delete dlinfo_;
  dlinfo_ = dlinfo;
  if (dlinfo) {
    set_has_dlinfo();
  } else {
    clear_has_dlinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:com.zte.netanalysis.capcontrol.TcpSessionNotify.dlInfo)
}

// optional .com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo ulInfo = 5;
inline bool TcpSessionNotify::has_ulinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TcpSessionNotify::set_has_ulinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TcpSessionNotify::clear_has_ulinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TcpSessionNotify::clear_ulinfo() {
  if (ulinfo_ != NULL) ulinfo_->::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo::Clear();
  clear_has_ulinfo();
}
inline const ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo& TcpSessionNotify::ulinfo() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.TcpSessionNotify.ulInfo)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ulinfo_ != NULL ? *ulinfo_ : *default_instance().ulinfo_;
#else
  return ulinfo_ != NULL ? *ulinfo_ : *default_instance_->ulinfo_;
#endif
}
inline ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo* TcpSessionNotify::mutable_ulinfo() {
  set_has_ulinfo();
  if (ulinfo_ == NULL) ulinfo_ = new ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo;
  // @@protoc_insertion_point(field_mutable:com.zte.netanalysis.capcontrol.TcpSessionNotify.ulInfo)
  return ulinfo_;
}
inline ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo* TcpSessionNotify::release_ulinfo() {
  clear_has_ulinfo();
  ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo* temp = ulinfo_;
  ulinfo_ = NULL;
  return temp;
}
inline void TcpSessionNotify::set_allocated_ulinfo(::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo* ulinfo) {
  delete ulinfo_;
  ulinfo_ = ulinfo;
  if (ulinfo) {
    set_has_ulinfo();
  } else {
    clear_has_ulinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:com.zte.netanalysis.capcontrol.TcpSessionNotify.ulInfo)
}

// -------------------------------------------------------------------

// DnsTransNotify

// optional uint32 retryCount = 1;
inline bool DnsTransNotify::has_retrycount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DnsTransNotify::set_has_retrycount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DnsTransNotify::clear_has_retrycount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DnsTransNotify::clear_retrycount() {
  retrycount_ = 0u;
  clear_has_retrycount();
}
inline ::google::protobuf::uint32 DnsTransNotify::retrycount() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.DnsTransNotify.retryCount)
  return retrycount_;
}
inline void DnsTransNotify::set_retrycount(::google::protobuf::uint32 value) {
  set_has_retrycount();
  retrycount_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.DnsTransNotify.retryCount)
}

// optional uint64 queryTime = 2;
inline bool DnsTransNotify::has_querytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DnsTransNotify::set_has_querytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DnsTransNotify::clear_has_querytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DnsTransNotify::clear_querytime() {
  querytime_ = GOOGLE_ULONGLONG(0);
  clear_has_querytime();
}
inline ::google::protobuf::uint64 DnsTransNotify::querytime() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.DnsTransNotify.queryTime)
  return querytime_;
}
inline void DnsTransNotify::set_querytime(::google::protobuf::uint64 value) {
  set_has_querytime();
  querytime_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.DnsTransNotify.queryTime)
}

// optional uint64 answerTime = 3;
inline bool DnsTransNotify::has_answertime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DnsTransNotify::set_has_answertime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DnsTransNotify::clear_has_answertime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DnsTransNotify::clear_answertime() {
  answertime_ = GOOGLE_ULONGLONG(0);
  clear_has_answertime();
}
inline ::google::protobuf::uint64 DnsTransNotify::answertime() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.DnsTransNotify.answerTime)
  return answertime_;
}
inline void DnsTransNotify::set_answertime(::google::protobuf::uint64 value) {
  set_has_answertime();
  answertime_ = value;
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.DnsTransNotify.answerTime)
}

// optional string dnsServerIp = 4;
inline bool DnsTransNotify::has_dnsserverip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DnsTransNotify::set_has_dnsserverip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DnsTransNotify::clear_has_dnsserverip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DnsTransNotify::clear_dnsserverip() {
  if (dnsserverip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dnsserverip_->clear();
  }
  clear_has_dnsserverip();
}
inline const ::std::string& DnsTransNotify::dnsserverip() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.DnsTransNotify.dnsServerIp)
  return *dnsserverip_;
}
inline void DnsTransNotify::set_dnsserverip(const ::std::string& value) {
  set_has_dnsserverip();
  if (dnsserverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dnsserverip_ = new ::std::string;
  }
  dnsserverip_->assign(value);
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.DnsTransNotify.dnsServerIp)
}
inline void DnsTransNotify::set_dnsserverip(const char* value) {
  set_has_dnsserverip();
  if (dnsserverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dnsserverip_ = new ::std::string;
  }
  dnsserverip_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zte.netanalysis.capcontrol.DnsTransNotify.dnsServerIp)
}
inline void DnsTransNotify::set_dnsserverip(const char* value, size_t size) {
  set_has_dnsserverip();
  if (dnsserverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dnsserverip_ = new ::std::string;
  }
  dnsserverip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zte.netanalysis.capcontrol.DnsTransNotify.dnsServerIp)
}
inline ::std::string* DnsTransNotify::mutable_dnsserverip() {
  set_has_dnsserverip();
  if (dnsserverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dnsserverip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zte.netanalysis.capcontrol.DnsTransNotify.dnsServerIp)
  return dnsserverip_;
}
inline ::std::string* DnsTransNotify::release_dnsserverip() {
  clear_has_dnsserverip();
  if (dnsserverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dnsserverip_;
    dnsserverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DnsTransNotify::set_allocated_dnsserverip(::std::string* dnsserverip) {
  if (dnsserverip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dnsserverip_;
  }
  if (dnsserverip) {
    set_has_dnsserverip();
    dnsserverip_ = dnsserverip;
  } else {
    clear_has_dnsserverip();
    dnsserverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zte.netanalysis.capcontrol.DnsTransNotify.dnsServerIp)
}

// optional string hostName = 5;
inline bool DnsTransNotify::has_hostname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DnsTransNotify::set_has_hostname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DnsTransNotify::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DnsTransNotify::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& DnsTransNotify::hostname() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.DnsTransNotify.hostName)
  return *hostname_;
}
inline void DnsTransNotify::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.DnsTransNotify.hostName)
}
inline void DnsTransNotify::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zte.netanalysis.capcontrol.DnsTransNotify.hostName)
}
inline void DnsTransNotify::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zte.netanalysis.capcontrol.DnsTransNotify.hostName)
}
inline ::std::string* DnsTransNotify::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zte.netanalysis.capcontrol.DnsTransNotify.hostName)
  return hostname_;
}
inline ::std::string* DnsTransNotify::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DnsTransNotify::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zte.netanalysis.capcontrol.DnsTransNotify.hostName)
}

// optional string ipAddr = 6;
inline bool DnsTransNotify::has_ipaddr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DnsTransNotify::set_has_ipaddr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DnsTransNotify::clear_has_ipaddr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DnsTransNotify::clear_ipaddr() {
  if (ipaddr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipaddr_->clear();
  }
  clear_has_ipaddr();
}
inline const ::std::string& DnsTransNotify::ipaddr() const {
  // @@protoc_insertion_point(field_get:com.zte.netanalysis.capcontrol.DnsTransNotify.ipAddr)
  return *ipaddr_;
}
inline void DnsTransNotify::set_ipaddr(const ::std::string& value) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(value);
  // @@protoc_insertion_point(field_set:com.zte.netanalysis.capcontrol.DnsTransNotify.ipAddr)
}
inline void DnsTransNotify::set_ipaddr(const char* value) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zte.netanalysis.capcontrol.DnsTransNotify.ipAddr)
}
inline void DnsTransNotify::set_ipaddr(const char* value, size_t size) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zte.netanalysis.capcontrol.DnsTransNotify.ipAddr)
}
inline ::std::string* DnsTransNotify::mutable_ipaddr() {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipaddr_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zte.netanalysis.capcontrol.DnsTransNotify.ipAddr)
  return ipaddr_;
}
inline ::std::string* DnsTransNotify::release_ipaddr() {
  clear_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ipaddr_;
    ipaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DnsTransNotify::set_allocated_ipaddr(::std::string* ipaddr) {
  if (ipaddr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ipaddr_;
  }
  if (ipaddr) {
    set_has_ipaddr();
    ipaddr_ = ipaddr;
  } else {
    clear_has_ipaddr();
    ipaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zte.netanalysis.capcontrol.DnsTransNotify.ipAddr)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace capcontrol
}  // namespace netanalysis
}  // namespace zte
}  // namespace com

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
