// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "message.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace zte {
namespace netanalysis {
namespace capcontrol {

void protobuf_ShutdownFile_message_2eproto() {
  delete StartCapReq::default_instance_;
  delete StartCapRes::default_instance_;
  delete StopCapReq::default_instance_;
  delete StopCapRes::default_instance_;
  delete IpStatNotify::default_instance_;
  delete TcpStatNotify::default_instance_;
  delete TcpStatNotify_DirStat::default_instance_;
  delete TcpSessionNotify::default_instance_;
  delete TcpSessionNotify_IpPort::default_instance_;
  delete TcpSessionNotify_FlowInfo::default_instance_;
  delete DnsTransNotify::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_message_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_message_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  StartCapReq::default_instance_ = new StartCapReq();
  StartCapRes::default_instance_ = new StartCapRes();
  StopCapReq::default_instance_ = new StopCapReq();
  StopCapRes::default_instance_ = new StopCapRes();
  IpStatNotify::default_instance_ = new IpStatNotify();
  TcpStatNotify::default_instance_ = new TcpStatNotify();
  TcpStatNotify_DirStat::default_instance_ = new TcpStatNotify_DirStat();
  TcpSessionNotify::default_instance_ = new TcpSessionNotify();
  TcpSessionNotify_IpPort::default_instance_ = new TcpSessionNotify_IpPort();
  TcpSessionNotify_FlowInfo::default_instance_ = new TcpSessionNotify_FlowInfo();
  DnsTransNotify::default_instance_ = new DnsTransNotify();
  StartCapReq::default_instance_->InitAsDefaultInstance();
  StartCapRes::default_instance_->InitAsDefaultInstance();
  StopCapReq::default_instance_->InitAsDefaultInstance();
  StopCapRes::default_instance_->InitAsDefaultInstance();
  IpStatNotify::default_instance_->InitAsDefaultInstance();
  TcpStatNotify::default_instance_->InitAsDefaultInstance();
  TcpStatNotify_DirStat::default_instance_->InitAsDefaultInstance();
  TcpSessionNotify::default_instance_->InitAsDefaultInstance();
  TcpSessionNotify_IpPort::default_instance_->InitAsDefaultInstance();
  TcpSessionNotify_FlowInfo::default_instance_->InitAsDefaultInstance();
  DnsTransNotify::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_message_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_message_2eproto_once_);
void protobuf_AddDesc_message_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_message_2eproto_once_,
                 &protobuf_AddDesc_message_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_message_2eproto {
  StaticDescriptorInitializer_message_2eproto() {
    protobuf_AddDesc_message_2eproto();
  }
} static_descriptor_initializer_message_2eproto_;
#endif
bool MsgType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int StartCapReq::kSeqFieldNumber;
const int StartCapReq::kUrlFieldNumber;
const int StartCapReq::kSaveFileFieldNumber;
const int StartCapReq::kTcpStatIntervalFieldNumber;
#endif  // !_MSC_VER

StartCapReq::StartCapReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.zte.netanalysis.capcontrol.StartCapReq)
}

void StartCapReq::InitAsDefaultInstance() {
}

StartCapReq::StartCapReq(const StartCapReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.zte.netanalysis.capcontrol.StartCapReq)
}

void StartCapReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  seq_ = 0;
  url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  savefile_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  tcpstatinterval_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartCapReq::~StartCapReq() {
  // @@protoc_insertion_point(destructor:com.zte.netanalysis.capcontrol.StartCapReq)
  SharedDtor();
}

void StartCapReq::SharedDtor() {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete url_;
  }
  if (savefile_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete savefile_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartCapReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartCapReq& StartCapReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

StartCapReq* StartCapReq::default_instance_ = NULL;

StartCapReq* StartCapReq::New() const {
  return new StartCapReq;
}

void StartCapReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<StartCapReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(seq_, tcpstatinterval_);
    if (has_url()) {
      if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        url_->clear();
      }
    }
    if (has_savefile()) {
      if (savefile_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        savefile_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool StartCapReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.zte.netanalysis.capcontrol.StartCapReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 seq = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_url;
        break;
      }

      // optional string url = 2;
      case 2: {
        if (tag == 18) {
         parse_url:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_url()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_saveFile;
        break;
      }

      // optional string saveFile = 3;
      case 3: {
        if (tag == 26) {
         parse_saveFile:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_savefile()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_tcpStatInterval;
        break;
      }

      // optional uint32 tcpStatInterval = 4;
      case 4: {
        if (tag == 32) {
         parse_tcpStatInterval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tcpstatinterval_)));
          set_has_tcpstatinterval();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.zte.netanalysis.capcontrol.StartCapReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.zte.netanalysis.capcontrol.StartCapReq)
  return false;
#undef DO_
}

void StartCapReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.zte.netanalysis.capcontrol.StartCapReq)
  // required int32 seq = 1;
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->seq(), output);
  }

  // optional string url = 2;
  if (has_url()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->url(), output);
  }

  // optional string saveFile = 3;
  if (has_savefile()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->savefile(), output);
  }

  // optional uint32 tcpStatInterval = 4;
  if (has_tcpstatinterval()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->tcpstatinterval(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.zte.netanalysis.capcontrol.StartCapReq)
}

int StartCapReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 seq = 1;
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seq());
    }

    // optional string url = 2;
    if (has_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->url());
    }

    // optional string saveFile = 3;
    if (has_savefile()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->savefile());
    }

    // optional uint32 tcpStatInterval = 4;
    if (has_tcpstatinterval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tcpstatinterval());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartCapReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartCapReq*>(&from));
}

void StartCapReq::MergeFrom(const StartCapReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seq()) {
      set_seq(from.seq());
    }
    if (from.has_url()) {
      set_url(from.url());
    }
    if (from.has_savefile()) {
      set_savefile(from.savefile());
    }
    if (from.has_tcpstatinterval()) {
      set_tcpstatinterval(from.tcpstatinterval());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void StartCapReq::CopyFrom(const StartCapReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartCapReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StartCapReq::Swap(StartCapReq* other) {
  if (other != this) {
    std::swap(seq_, other->seq_);
    std::swap(url_, other->url_);
    std::swap(savefile_, other->savefile_);
    std::swap(tcpstatinterval_, other->tcpstatinterval_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StartCapReq::GetTypeName() const {
  return "com.zte.netanalysis.capcontrol.StartCapReq";
}


// ===================================================================

#ifndef _MSC_VER
const int StartCapRes::kSeqFieldNumber;
const int StartCapRes::kAckFieldNumber;
const int StartCapRes::kTimeFieldNumber;
#endif  // !_MSC_VER

StartCapRes::StartCapRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.zte.netanalysis.capcontrol.StartCapRes)
}

void StartCapRes::InitAsDefaultInstance() {
}

StartCapRes::StartCapRes(const StartCapRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.zte.netanalysis.capcontrol.StartCapRes)
}

void StartCapRes::SharedCtor() {
  _cached_size_ = 0;
  seq_ = 0;
  ack_ = 0;
  time_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartCapRes::~StartCapRes() {
  // @@protoc_insertion_point(destructor:com.zte.netanalysis.capcontrol.StartCapRes)
  SharedDtor();
}

void StartCapRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartCapRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartCapRes& StartCapRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

StartCapRes* StartCapRes::default_instance_ = NULL;

StartCapRes* StartCapRes::New() const {
  return new StartCapRes;
}

void StartCapRes::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<StartCapRes*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(seq_, time_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool StartCapRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.zte.netanalysis.capcontrol.StartCapRes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 seq = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ack;
        break;
      }

      // required int32 ack = 2;
      case 2: {
        if (tag == 16) {
         parse_ack:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ack_)));
          set_has_ack();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_time;
        break;
      }

      // required uint64 time = 3;
      case 3: {
        if (tag == 24) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.zte.netanalysis.capcontrol.StartCapRes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.zte.netanalysis.capcontrol.StartCapRes)
  return false;
#undef DO_
}

void StartCapRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.zte.netanalysis.capcontrol.StartCapRes)
  // required int32 seq = 1;
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->seq(), output);
  }

  // required int32 ack = 2;
  if (has_ack()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->ack(), output);
  }

  // required uint64 time = 3;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->time(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.zte.netanalysis.capcontrol.StartCapRes)
}

int StartCapRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 seq = 1;
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seq());
    }

    // required int32 ack = 2;
    if (has_ack()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ack());
    }

    // required uint64 time = 3;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->time());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartCapRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartCapRes*>(&from));
}

void StartCapRes::MergeFrom(const StartCapRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seq()) {
      set_seq(from.seq());
    }
    if (from.has_ack()) {
      set_ack(from.ack());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void StartCapRes::CopyFrom(const StartCapRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartCapRes::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void StartCapRes::Swap(StartCapRes* other) {
  if (other != this) {
    std::swap(seq_, other->seq_);
    std::swap(ack_, other->ack_);
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StartCapRes::GetTypeName() const {
  return "com.zte.netanalysis.capcontrol.StartCapRes";
}


// ===================================================================

#ifndef _MSC_VER
const int StopCapReq::kSeqFieldNumber;
#endif  // !_MSC_VER

StopCapReq::StopCapReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.zte.netanalysis.capcontrol.StopCapReq)
}

void StopCapReq::InitAsDefaultInstance() {
}

StopCapReq::StopCapReq(const StopCapReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.zte.netanalysis.capcontrol.StopCapReq)
}

void StopCapReq::SharedCtor() {
  _cached_size_ = 0;
  seq_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StopCapReq::~StopCapReq() {
  // @@protoc_insertion_point(destructor:com.zte.netanalysis.capcontrol.StopCapReq)
  SharedDtor();
}

void StopCapReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StopCapReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StopCapReq& StopCapReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

StopCapReq* StopCapReq::default_instance_ = NULL;

StopCapReq* StopCapReq::New() const {
  return new StopCapReq;
}

void StopCapReq::Clear() {
  seq_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool StopCapReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.zte.netanalysis.capcontrol.StopCapReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 seq = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.zte.netanalysis.capcontrol.StopCapReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.zte.netanalysis.capcontrol.StopCapReq)
  return false;
#undef DO_
}

void StopCapReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.zte.netanalysis.capcontrol.StopCapReq)
  // required int32 seq = 1;
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->seq(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.zte.netanalysis.capcontrol.StopCapReq)
}

int StopCapReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 seq = 1;
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seq());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StopCapReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StopCapReq*>(&from));
}

void StopCapReq::MergeFrom(const StopCapReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seq()) {
      set_seq(from.seq());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void StopCapReq::CopyFrom(const StopCapReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StopCapReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StopCapReq::Swap(StopCapReq* other) {
  if (other != this) {
    std::swap(seq_, other->seq_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StopCapReq::GetTypeName() const {
  return "com.zte.netanalysis.capcontrol.StopCapReq";
}


// ===================================================================

#ifndef _MSC_VER
const int StopCapRes::kSeqFieldNumber;
const int StopCapRes::kTimeFieldNumber;
const int StopCapRes::kTotalSecsFieldNumber;
const int StopCapRes::kTotalPktNumFieldNumber;
const int StopCapRes::kDroppedPktNumFieldNumber;
#endif  // !_MSC_VER

StopCapRes::StopCapRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.zte.netanalysis.capcontrol.StopCapRes)
}

void StopCapRes::InitAsDefaultInstance() {
}

StopCapRes::StopCapRes(const StopCapRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.zte.netanalysis.capcontrol.StopCapRes)
}

void StopCapRes::SharedCtor() {
  _cached_size_ = 0;
  seq_ = 0;
  time_ = GOOGLE_ULONGLONG(0);
  totalsecs_ = 0u;
  totalpktnum_ = 0u;
  droppedpktnum_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StopCapRes::~StopCapRes() {
  // @@protoc_insertion_point(destructor:com.zte.netanalysis.capcontrol.StopCapRes)
  SharedDtor();
}

void StopCapRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StopCapRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StopCapRes& StopCapRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

StopCapRes* StopCapRes::default_instance_ = NULL;

StopCapRes* StopCapRes::New() const {
  return new StopCapRes;
}

void StopCapRes::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<StopCapRes*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(time_, droppedpktnum_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool StopCapRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.zte.netanalysis.capcontrol.StopCapRes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 seq = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time;
        break;
      }

      // required uint64 time = 2;
      case 2: {
        if (tag == 16) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_totalSecs;
        break;
      }

      // optional uint32 totalSecs = 3;
      case 3: {
        if (tag == 24) {
         parse_totalSecs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &totalsecs_)));
          set_has_totalsecs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_totalPktNum;
        break;
      }

      // optional uint32 totalPktNum = 4;
      case 4: {
        if (tag == 32) {
         parse_totalPktNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &totalpktnum_)));
          set_has_totalpktnum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_droppedPktNum;
        break;
      }

      // optional uint32 droppedPktNum = 5;
      case 5: {
        if (tag == 40) {
         parse_droppedPktNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &droppedpktnum_)));
          set_has_droppedpktnum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.zte.netanalysis.capcontrol.StopCapRes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.zte.netanalysis.capcontrol.StopCapRes)
  return false;
#undef DO_
}

void StopCapRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.zte.netanalysis.capcontrol.StopCapRes)
  // required int32 seq = 1;
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->seq(), output);
  }

  // required uint64 time = 2;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->time(), output);
  }

  // optional uint32 totalSecs = 3;
  if (has_totalsecs()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->totalsecs(), output);
  }

  // optional uint32 totalPktNum = 4;
  if (has_totalpktnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->totalpktnum(), output);
  }

  // optional uint32 droppedPktNum = 5;
  if (has_droppedpktnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->droppedpktnum(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.zte.netanalysis.capcontrol.StopCapRes)
}

int StopCapRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 seq = 1;
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seq());
    }

    // required uint64 time = 2;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->time());
    }

    // optional uint32 totalSecs = 3;
    if (has_totalsecs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->totalsecs());
    }

    // optional uint32 totalPktNum = 4;
    if (has_totalpktnum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->totalpktnum());
    }

    // optional uint32 droppedPktNum = 5;
    if (has_droppedpktnum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->droppedpktnum());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StopCapRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StopCapRes*>(&from));
}

void StopCapRes::MergeFrom(const StopCapRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seq()) {
      set_seq(from.seq());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_totalsecs()) {
      set_totalsecs(from.totalsecs());
    }
    if (from.has_totalpktnum()) {
      set_totalpktnum(from.totalpktnum());
    }
    if (from.has_droppedpktnum()) {
      set_droppedpktnum(from.droppedpktnum());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void StopCapRes::CopyFrom(const StopCapRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StopCapRes::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void StopCapRes::Swap(StopCapRes* other) {
  if (other != this) {
    std::swap(seq_, other->seq_);
    std::swap(time_, other->time_);
    std::swap(totalsecs_, other->totalsecs_);
    std::swap(totalpktnum_, other->totalpktnum_);
    std::swap(droppedpktnum_, other->droppedpktnum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StopCapRes::GetTypeName() const {
  return "com.zte.netanalysis.capcontrol.StopCapRes";
}


// ===================================================================

#ifndef _MSC_VER
const int IpStatNotify::kStartTimeFieldNumber;
const int IpStatNotify::kEndTimeFieldNumber;
const int IpStatNotify::kPktNumFieldNumber;
const int IpStatNotify::kBytesFieldNumber;
#endif  // !_MSC_VER

IpStatNotify::IpStatNotify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.zte.netanalysis.capcontrol.IpStatNotify)
}

void IpStatNotify::InitAsDefaultInstance() {
}

IpStatNotify::IpStatNotify(const IpStatNotify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.zte.netanalysis.capcontrol.IpStatNotify)
}

void IpStatNotify::SharedCtor() {
  _cached_size_ = 0;
  starttime_ = GOOGLE_ULONGLONG(0);
  endtime_ = GOOGLE_ULONGLONG(0);
  pktnum_ = 0u;
  bytes_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IpStatNotify::~IpStatNotify() {
  // @@protoc_insertion_point(destructor:com.zte.netanalysis.capcontrol.IpStatNotify)
  SharedDtor();
}

void IpStatNotify::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IpStatNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IpStatNotify& IpStatNotify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

IpStatNotify* IpStatNotify::default_instance_ = NULL;

IpStatNotify* IpStatNotify::New() const {
  return new IpStatNotify;
}

void IpStatNotify::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IpStatNotify*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(starttime_, bytes_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IpStatNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.zte.netanalysis.capcontrol.IpStatNotify)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 startTime = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &starttime_)));
          set_has_starttime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_endTime;
        break;
      }

      // required uint64 endTime = 2;
      case 2: {
        if (tag == 16) {
         parse_endTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &endtime_)));
          set_has_endtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_pktNum;
        break;
      }

      // optional uint32 pktNum = 3;
      case 3: {
        if (tag == 24) {
         parse_pktNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pktnum_)));
          set_has_pktnum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_bytes;
        break;
      }

      // optional uint32 bytes = 4;
      case 4: {
        if (tag == 32) {
         parse_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bytes_)));
          set_has_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.zte.netanalysis.capcontrol.IpStatNotify)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.zte.netanalysis.capcontrol.IpStatNotify)
  return false;
#undef DO_
}

void IpStatNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.zte.netanalysis.capcontrol.IpStatNotify)
  // required uint64 startTime = 1;
  if (has_starttime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->starttime(), output);
  }

  // required uint64 endTime = 2;
  if (has_endtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->endtime(), output);
  }

  // optional uint32 pktNum = 3;
  if (has_pktnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->pktnum(), output);
  }

  // optional uint32 bytes = 4;
  if (has_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->bytes(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.zte.netanalysis.capcontrol.IpStatNotify)
}

int IpStatNotify::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 startTime = 1;
    if (has_starttime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->starttime());
    }

    // required uint64 endTime = 2;
    if (has_endtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->endtime());
    }

    // optional uint32 pktNum = 3;
    if (has_pktnum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pktnum());
    }

    // optional uint32 bytes = 4;
    if (has_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bytes());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IpStatNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IpStatNotify*>(&from));
}

void IpStatNotify::MergeFrom(const IpStatNotify& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_starttime()) {
      set_starttime(from.starttime());
    }
    if (from.has_endtime()) {
      set_endtime(from.endtime());
    }
    if (from.has_pktnum()) {
      set_pktnum(from.pktnum());
    }
    if (from.has_bytes()) {
      set_bytes(from.bytes());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IpStatNotify::CopyFrom(const IpStatNotify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IpStatNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IpStatNotify::Swap(IpStatNotify* other) {
  if (other != this) {
    std::swap(starttime_, other->starttime_);
    std::swap(endtime_, other->endtime_);
    std::swap(pktnum_, other->pktnum_);
    std::swap(bytes_, other->bytes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IpStatNotify::GetTypeName() const {
  return "com.zte.netanalysis.capcontrol.IpStatNotify";
}


// ===================================================================

#ifndef _MSC_VER
const int TcpStatNotify_DirStat::kPktNumFieldNumber;
const int TcpStatNotify_DirStat::kBytesFieldNumber;
const int TcpStatNotify_DirStat::kRetransNumFieldNumber;
const int TcpStatNotify_DirStat::kRetransBytesFieldNumber;
const int TcpStatNotify_DirStat::kRetransAckedNumFieldNumber;
const int TcpStatNotify_DirStat::kRetransAckedBytesFieldNumber;
#endif  // !_MSC_VER

TcpStatNotify_DirStat::TcpStatNotify_DirStat()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat)
}

void TcpStatNotify_DirStat::InitAsDefaultInstance() {
}

TcpStatNotify_DirStat::TcpStatNotify_DirStat(const TcpStatNotify_DirStat& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat)
}

void TcpStatNotify_DirStat::SharedCtor() {
  _cached_size_ = 0;
  pktnum_ = 0u;
  bytes_ = 0u;
  retransnum_ = 0u;
  retransbytes_ = 0u;
  retransackednum_ = 0u;
  retransackedbytes_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TcpStatNotify_DirStat::~TcpStatNotify_DirStat() {
  // @@protoc_insertion_point(destructor:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat)
  SharedDtor();
}

void TcpStatNotify_DirStat::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TcpStatNotify_DirStat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TcpStatNotify_DirStat& TcpStatNotify_DirStat::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

TcpStatNotify_DirStat* TcpStatNotify_DirStat::default_instance_ = NULL;

TcpStatNotify_DirStat* TcpStatNotify_DirStat::New() const {
  return new TcpStatNotify_DirStat;
}

void TcpStatNotify_DirStat::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TcpStatNotify_DirStat*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(pktnum_, retransackedbytes_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool TcpStatNotify_DirStat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 pktNum = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pktnum_)));
          set_has_pktnum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_bytes;
        break;
      }

      // optional uint32 bytes = 2;
      case 2: {
        if (tag == 16) {
         parse_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bytes_)));
          set_has_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_retransNum;
        break;
      }

      // optional uint32 retransNum = 3;
      case 3: {
        if (tag == 24) {
         parse_retransNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &retransnum_)));
          set_has_retransnum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_retransBytes;
        break;
      }

      // optional uint32 retransBytes = 4;
      case 4: {
        if (tag == 32) {
         parse_retransBytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &retransbytes_)));
          set_has_retransbytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_retransAckedNum;
        break;
      }

      // optional uint32 retransAckedNum = 5;
      case 5: {
        if (tag == 40) {
         parse_retransAckedNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &retransackednum_)));
          set_has_retransackednum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_retransAckedBytes;
        break;
      }

      // optional uint32 retransAckedBytes = 6;
      case 6: {
        if (tag == 48) {
         parse_retransAckedBytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &retransackedbytes_)));
          set_has_retransackedbytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat)
  return false;
#undef DO_
}

void TcpStatNotify_DirStat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat)
  // optional uint32 pktNum = 1;
  if (has_pktnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->pktnum(), output);
  }

  // optional uint32 bytes = 2;
  if (has_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->bytes(), output);
  }

  // optional uint32 retransNum = 3;
  if (has_retransnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->retransnum(), output);
  }

  // optional uint32 retransBytes = 4;
  if (has_retransbytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->retransbytes(), output);
  }

  // optional uint32 retransAckedNum = 5;
  if (has_retransackednum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->retransackednum(), output);
  }

  // optional uint32 retransAckedBytes = 6;
  if (has_retransackedbytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->retransackedbytes(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat)
}

int TcpStatNotify_DirStat::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 pktNum = 1;
    if (has_pktnum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pktnum());
    }

    // optional uint32 bytes = 2;
    if (has_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bytes());
    }

    // optional uint32 retransNum = 3;
    if (has_retransnum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->retransnum());
    }

    // optional uint32 retransBytes = 4;
    if (has_retransbytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->retransbytes());
    }

    // optional uint32 retransAckedNum = 5;
    if (has_retransackednum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->retransackednum());
    }

    // optional uint32 retransAckedBytes = 6;
    if (has_retransackedbytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->retransackedbytes());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TcpStatNotify_DirStat::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TcpStatNotify_DirStat*>(&from));
}

void TcpStatNotify_DirStat::MergeFrom(const TcpStatNotify_DirStat& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pktnum()) {
      set_pktnum(from.pktnum());
    }
    if (from.has_bytes()) {
      set_bytes(from.bytes());
    }
    if (from.has_retransnum()) {
      set_retransnum(from.retransnum());
    }
    if (from.has_retransbytes()) {
      set_retransbytes(from.retransbytes());
    }
    if (from.has_retransackednum()) {
      set_retransackednum(from.retransackednum());
    }
    if (from.has_retransackedbytes()) {
      set_retransackedbytes(from.retransackedbytes());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void TcpStatNotify_DirStat::CopyFrom(const TcpStatNotify_DirStat& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TcpStatNotify_DirStat::IsInitialized() const {

  return true;
}

void TcpStatNotify_DirStat::Swap(TcpStatNotify_DirStat* other) {
  if (other != this) {
    std::swap(pktnum_, other->pktnum_);
    std::swap(bytes_, other->bytes_);
    std::swap(retransnum_, other->retransnum_);
    std::swap(retransbytes_, other->retransbytes_);
    std::swap(retransackednum_, other->retransackednum_);
    std::swap(retransackedbytes_, other->retransackedbytes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TcpStatNotify_DirStat::GetTypeName() const {
  return "com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TcpStatNotify::kStartTimeFieldNumber;
const int TcpStatNotify::kEndTimeFieldNumber;
const int TcpStatNotify::kSessionIdFieldNumber;
const int TcpStatNotify::kDlStatFieldNumber;
const int TcpStatNotify::kUlStatFieldNumber;
#endif  // !_MSC_VER

TcpStatNotify::TcpStatNotify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.zte.netanalysis.capcontrol.TcpStatNotify)
}

void TcpStatNotify::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  dlstat_ = const_cast< ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat*>(
      ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat::internal_default_instance());
#else
  dlstat_ = const_cast< ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat*>(&::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  ulstat_ = const_cast< ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat*>(
      ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat::internal_default_instance());
#else
  ulstat_ = const_cast< ::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat*>(&::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat::default_instance());
#endif
}

TcpStatNotify::TcpStatNotify(const TcpStatNotify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.zte.netanalysis.capcontrol.TcpStatNotify)
}

void TcpStatNotify::SharedCtor() {
  _cached_size_ = 0;
  starttime_ = GOOGLE_ULONGLONG(0);
  endtime_ = GOOGLE_ULONGLONG(0);
  sessionid_ = 0u;
  dlstat_ = NULL;
  ulstat_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TcpStatNotify::~TcpStatNotify() {
  // @@protoc_insertion_point(destructor:com.zte.netanalysis.capcontrol.TcpStatNotify)
  SharedDtor();
}

void TcpStatNotify::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete dlstat_;
    delete ulstat_;
  }
}

void TcpStatNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TcpStatNotify& TcpStatNotify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

TcpStatNotify* TcpStatNotify::default_instance_ = NULL;

TcpStatNotify* TcpStatNotify::New() const {
  return new TcpStatNotify;
}

void TcpStatNotify::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TcpStatNotify*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(starttime_, endtime_);
    sessionid_ = 0u;
    if (has_dlstat()) {
      if (dlstat_ != NULL) dlstat_->::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat::Clear();
    }
    if (has_ulstat()) {
      if (ulstat_ != NULL) ulstat_->::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool TcpStatNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.zte.netanalysis.capcontrol.TcpStatNotify)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 startTime = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &starttime_)));
          set_has_starttime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_endTime;
        break;
      }

      // required uint64 endTime = 2;
      case 2: {
        if (tag == 16) {
         parse_endTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &endtime_)));
          set_has_endtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_sessionId;
        break;
      }

      // required uint32 sessionId = 3;
      case 3: {
        if (tag == 24) {
         parse_sessionId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sessionid_)));
          set_has_sessionid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_dlStat;
        break;
      }

      // optional .com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat dlStat = 4;
      case 4: {
        if (tag == 34) {
         parse_dlStat:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dlstat()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_ulStat;
        break;
      }

      // optional .com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat ulStat = 5;
      case 5: {
        if (tag == 42) {
         parse_ulStat:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ulstat()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.zte.netanalysis.capcontrol.TcpStatNotify)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.zte.netanalysis.capcontrol.TcpStatNotify)
  return false;
#undef DO_
}

void TcpStatNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.zte.netanalysis.capcontrol.TcpStatNotify)
  // required uint64 startTime = 1;
  if (has_starttime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->starttime(), output);
  }

  // required uint64 endTime = 2;
  if (has_endtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->endtime(), output);
  }

  // required uint32 sessionId = 3;
  if (has_sessionid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->sessionid(), output);
  }

  // optional .com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat dlStat = 4;
  if (has_dlstat()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->dlstat(), output);
  }

  // optional .com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat ulStat = 5;
  if (has_ulstat()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->ulstat(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.zte.netanalysis.capcontrol.TcpStatNotify)
}

int TcpStatNotify::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 startTime = 1;
    if (has_starttime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->starttime());
    }

    // required uint64 endTime = 2;
    if (has_endtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->endtime());
    }

    // required uint32 sessionId = 3;
    if (has_sessionid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sessionid());
    }

    // optional .com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat dlStat = 4;
    if (has_dlstat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dlstat());
    }

    // optional .com.zte.netanalysis.capcontrol.TcpStatNotify.DirStat ulStat = 5;
    if (has_ulstat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ulstat());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TcpStatNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TcpStatNotify*>(&from));
}

void TcpStatNotify::MergeFrom(const TcpStatNotify& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_starttime()) {
      set_starttime(from.starttime());
    }
    if (from.has_endtime()) {
      set_endtime(from.endtime());
    }
    if (from.has_sessionid()) {
      set_sessionid(from.sessionid());
    }
    if (from.has_dlstat()) {
      mutable_dlstat()->::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat::MergeFrom(from.dlstat());
    }
    if (from.has_ulstat()) {
      mutable_ulstat()->::com::zte::netanalysis::capcontrol::TcpStatNotify_DirStat::MergeFrom(from.ulstat());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void TcpStatNotify::CopyFrom(const TcpStatNotify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TcpStatNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void TcpStatNotify::Swap(TcpStatNotify* other) {
  if (other != this) {
    std::swap(starttime_, other->starttime_);
    std::swap(endtime_, other->endtime_);
    std::swap(sessionid_, other->sessionid_);
    std::swap(dlstat_, other->dlstat_);
    std::swap(ulstat_, other->ulstat_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TcpStatNotify::GetTypeName() const {
  return "com.zte.netanalysis.capcontrol.TcpStatNotify";
}


// ===================================================================

#ifndef _MSC_VER
const int TcpSessionNotify_IpPort::kLocalIPFieldNumber;
const int TcpSessionNotify_IpPort::kRemoteIPFieldNumber;
const int TcpSessionNotify_IpPort::kLocalPortFieldNumber;
const int TcpSessionNotify_IpPort::kRemotePortFieldNumber;
#endif  // !_MSC_VER

TcpSessionNotify_IpPort::TcpSessionNotify_IpPort()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort)
}

void TcpSessionNotify_IpPort::InitAsDefaultInstance() {
}

TcpSessionNotify_IpPort::TcpSessionNotify_IpPort(const TcpSessionNotify_IpPort& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort)
}

void TcpSessionNotify_IpPort::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  localip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  remoteip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  localport_ = 0u;
  remoteport_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TcpSessionNotify_IpPort::~TcpSessionNotify_IpPort() {
  // @@protoc_insertion_point(destructor:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort)
  SharedDtor();
}

void TcpSessionNotify_IpPort::SharedDtor() {
  if (localip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete localip_;
  }
  if (remoteip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remoteip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TcpSessionNotify_IpPort::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TcpSessionNotify_IpPort& TcpSessionNotify_IpPort::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

TcpSessionNotify_IpPort* TcpSessionNotify_IpPort::default_instance_ = NULL;

TcpSessionNotify_IpPort* TcpSessionNotify_IpPort::New() const {
  return new TcpSessionNotify_IpPort;
}

void TcpSessionNotify_IpPort::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TcpSessionNotify_IpPort*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(localport_, remoteport_);
    if (has_localip()) {
      if (localip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        localip_->clear();
      }
    }
    if (has_remoteip()) {
      if (remoteip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        remoteip_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool TcpSessionNotify_IpPort::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string localIP = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_localip()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_remoteIP;
        break;
      }

      // required string remoteIP = 2;
      case 2: {
        if (tag == 18) {
         parse_remoteIP:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_remoteip()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_localPort;
        break;
      }

      // required uint32 localPort = 3;
      case 3: {
        if (tag == 24) {
         parse_localPort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &localport_)));
          set_has_localport();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_remotePort;
        break;
      }

      // required uint32 remotePort = 4;
      case 4: {
        if (tag == 32) {
         parse_remotePort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &remoteport_)));
          set_has_remoteport();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort)
  return false;
#undef DO_
}

void TcpSessionNotify_IpPort::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort)
  // required string localIP = 1;
  if (has_localip()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->localip(), output);
  }

  // required string remoteIP = 2;
  if (has_remoteip()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->remoteip(), output);
  }

  // required uint32 localPort = 3;
  if (has_localport()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->localport(), output);
  }

  // required uint32 remotePort = 4;
  if (has_remoteport()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->remoteport(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort)
}

int TcpSessionNotify_IpPort::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string localIP = 1;
    if (has_localip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->localip());
    }

    // required string remoteIP = 2;
    if (has_remoteip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->remoteip());
    }

    // required uint32 localPort = 3;
    if (has_localport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->localport());
    }

    // required uint32 remotePort = 4;
    if (has_remoteport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->remoteport());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TcpSessionNotify_IpPort::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TcpSessionNotify_IpPort*>(&from));
}

void TcpSessionNotify_IpPort::MergeFrom(const TcpSessionNotify_IpPort& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_localip()) {
      set_localip(from.localip());
    }
    if (from.has_remoteip()) {
      set_remoteip(from.remoteip());
    }
    if (from.has_localport()) {
      set_localport(from.localport());
    }
    if (from.has_remoteport()) {
      set_remoteport(from.remoteport());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void TcpSessionNotify_IpPort::CopyFrom(const TcpSessionNotify_IpPort& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TcpSessionNotify_IpPort::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void TcpSessionNotify_IpPort::Swap(TcpSessionNotify_IpPort* other) {
  if (other != this) {
    std::swap(localip_, other->localip_);
    std::swap(remoteip_, other->remoteip_);
    std::swap(localport_, other->localport_);
    std::swap(remoteport_, other->remoteport_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TcpSessionNotify_IpPort::GetTypeName() const {
  return "com.zte.netanalysis.capcontrol.TcpSessionNotify.IpPort";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TcpSessionNotify_FlowInfo::kBeginTimeFieldNumber;
const int TcpSessionNotify_FlowInfo::kEndTimeFieldNumber;
const int TcpSessionNotify_FlowInfo::kFirstPayloadTimeFieldNumber;
const int TcpSessionNotify_FlowInfo::kLastPayloadTimeFieldNumber;
const int TcpSessionNotify_FlowInfo::kTotalPktNumFieldNumber;
const int TcpSessionNotify_FlowInfo::kTotalBytesFieldNumber;
const int TcpSessionNotify_FlowInfo::kRetransPktNumFieldNumber;
const int TcpSessionNotify_FlowInfo::kRetransBytesFieldNumber;
const int TcpSessionNotify_FlowInfo::kRetransAckedNumFieldNumber;
const int TcpSessionNotify_FlowInfo::kRetransAckedBytesFieldNumber;
const int TcpSessionNotify_FlowInfo::kFastRetransNumFieldNumber;
const int TcpSessionNotify_FlowInfo::kFastRetransBytesFieldNumber;
const int TcpSessionNotify_FlowInfo::kDisorderPktNumFieldNumber;
const int TcpSessionNotify_FlowInfo::kDisorderBytesFieldNumber;
const int TcpSessionNotify_FlowInfo::kDupAckNumFieldNumber;
#endif  // !_MSC_VER

TcpSessionNotify_FlowInfo::TcpSessionNotify_FlowInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo)
}

void TcpSessionNotify_FlowInfo::InitAsDefaultInstance() {
}

TcpSessionNotify_FlowInfo::TcpSessionNotify_FlowInfo(const TcpSessionNotify_FlowInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo)
}

void TcpSessionNotify_FlowInfo::SharedCtor() {
  _cached_size_ = 0;
  begintime_ = GOOGLE_ULONGLONG(0);
  endtime_ = GOOGLE_ULONGLONG(0);
  firstpayloadtime_ = GOOGLE_ULONGLONG(0);
  lastpayloadtime_ = GOOGLE_ULONGLONG(0);
  totalpktnum_ = 0u;
  totalbytes_ = 0u;
  retranspktnum_ = 0u;
  retransbytes_ = 0u;
  retransackednum_ = 0u;
  retransackedbytes_ = 0u;
  fastretransnum_ = 0u;
  fastretransbytes_ = 0u;
  disorderpktnum_ = 0u;
  disorderbytes_ = 0u;
  dupacknum_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TcpSessionNotify_FlowInfo::~TcpSessionNotify_FlowInfo() {
  // @@protoc_insertion_point(destructor:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo)
  SharedDtor();
}

void TcpSessionNotify_FlowInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TcpSessionNotify_FlowInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TcpSessionNotify_FlowInfo& TcpSessionNotify_FlowInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

TcpSessionNotify_FlowInfo* TcpSessionNotify_FlowInfo::default_instance_ = NULL;

TcpSessionNotify_FlowInfo* TcpSessionNotify_FlowInfo::New() const {
  return new TcpSessionNotify_FlowInfo;
}

void TcpSessionNotify_FlowInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TcpSessionNotify_FlowInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(begintime_, retransbytes_);
  }
  if (_has_bits_[8 / 32] & 32512) {
    ZR_(retransackednum_, dupacknum_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool TcpSessionNotify_FlowInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 beginTime = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &begintime_)));
          set_has_begintime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_endTime;
        break;
      }

      // optional uint64 endTime = 2;
      case 2: {
        if (tag == 16) {
         parse_endTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &endtime_)));
          set_has_endtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_firstPayloadTime;
        break;
      }

      // optional uint64 firstPayloadTime = 3;
      case 3: {
        if (tag == 24) {
         parse_firstPayloadTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &firstpayloadtime_)));
          set_has_firstpayloadtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_lastPayloadTime;
        break;
      }

      // optional uint64 lastPayloadTime = 4;
      case 4: {
        if (tag == 32) {
         parse_lastPayloadTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &lastpayloadtime_)));
          set_has_lastpayloadtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_totalPktNum;
        break;
      }

      // optional uint32 totalPktNum = 5;
      case 5: {
        if (tag == 40) {
         parse_totalPktNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &totalpktnum_)));
          set_has_totalpktnum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_totalBytes;
        break;
      }

      // optional uint32 totalBytes = 6;
      case 6: {
        if (tag == 48) {
         parse_totalBytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &totalbytes_)));
          set_has_totalbytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_retransPktNum;
        break;
      }

      // optional uint32 retransPktNum = 7;
      case 7: {
        if (tag == 56) {
         parse_retransPktNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &retranspktnum_)));
          set_has_retranspktnum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_retransBytes;
        break;
      }

      // optional uint32 retransBytes = 8;
      case 8: {
        if (tag == 64) {
         parse_retransBytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &retransbytes_)));
          set_has_retransbytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_retransAckedNum;
        break;
      }

      // optional uint32 retransAckedNum = 9;
      case 9: {
        if (tag == 72) {
         parse_retransAckedNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &retransackednum_)));
          set_has_retransackednum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_retransAckedBytes;
        break;
      }

      // optional uint32 retransAckedBytes = 10;
      case 10: {
        if (tag == 80) {
         parse_retransAckedBytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &retransackedbytes_)));
          set_has_retransackedbytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_fastRetransNum;
        break;
      }

      // optional uint32 fastRetransNum = 11;
      case 11: {
        if (tag == 88) {
         parse_fastRetransNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fastretransnum_)));
          set_has_fastretransnum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_fastRetransBytes;
        break;
      }

      // optional uint32 fastRetransBytes = 12;
      case 12: {
        if (tag == 96) {
         parse_fastRetransBytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fastretransbytes_)));
          set_has_fastretransbytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_disorderPktNum;
        break;
      }

      // optional uint32 disorderPktNum = 13;
      case 13: {
        if (tag == 104) {
         parse_disorderPktNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &disorderpktnum_)));
          set_has_disorderpktnum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_disorderBytes;
        break;
      }

      // optional uint32 disorderBytes = 14;
      case 14: {
        if (tag == 112) {
         parse_disorderBytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &disorderbytes_)));
          set_has_disorderbytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_dupAckNum;
        break;
      }

      // optional uint32 dupAckNum = 15;
      case 15: {
        if (tag == 120) {
         parse_dupAckNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dupacknum_)));
          set_has_dupacknum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo)
  return false;
#undef DO_
}

void TcpSessionNotify_FlowInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo)
  // optional uint64 beginTime = 1;
  if (has_begintime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->begintime(), output);
  }

  // optional uint64 endTime = 2;
  if (has_endtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->endtime(), output);
  }

  // optional uint64 firstPayloadTime = 3;
  if (has_firstpayloadtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->firstpayloadtime(), output);
  }

  // optional uint64 lastPayloadTime = 4;
  if (has_lastpayloadtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->lastpayloadtime(), output);
  }

  // optional uint32 totalPktNum = 5;
  if (has_totalpktnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->totalpktnum(), output);
  }

  // optional uint32 totalBytes = 6;
  if (has_totalbytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->totalbytes(), output);
  }

  // optional uint32 retransPktNum = 7;
  if (has_retranspktnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->retranspktnum(), output);
  }

  // optional uint32 retransBytes = 8;
  if (has_retransbytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->retransbytes(), output);
  }

  // optional uint32 retransAckedNum = 9;
  if (has_retransackednum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->retransackednum(), output);
  }

  // optional uint32 retransAckedBytes = 10;
  if (has_retransackedbytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->retransackedbytes(), output);
  }

  // optional uint32 fastRetransNum = 11;
  if (has_fastretransnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->fastretransnum(), output);
  }

  // optional uint32 fastRetransBytes = 12;
  if (has_fastretransbytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->fastretransbytes(), output);
  }

  // optional uint32 disorderPktNum = 13;
  if (has_disorderpktnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->disorderpktnum(), output);
  }

  // optional uint32 disorderBytes = 14;
  if (has_disorderbytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(14, this->disorderbytes(), output);
  }

  // optional uint32 dupAckNum = 15;
  if (has_dupacknum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->dupacknum(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo)
}

int TcpSessionNotify_FlowInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 beginTime = 1;
    if (has_begintime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->begintime());
    }

    // optional uint64 endTime = 2;
    if (has_endtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->endtime());
    }

    // optional uint64 firstPayloadTime = 3;
    if (has_firstpayloadtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->firstpayloadtime());
    }

    // optional uint64 lastPayloadTime = 4;
    if (has_lastpayloadtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->lastpayloadtime());
    }

    // optional uint32 totalPktNum = 5;
    if (has_totalpktnum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->totalpktnum());
    }

    // optional uint32 totalBytes = 6;
    if (has_totalbytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->totalbytes());
    }

    // optional uint32 retransPktNum = 7;
    if (has_retranspktnum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->retranspktnum());
    }

    // optional uint32 retransBytes = 8;
    if (has_retransbytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->retransbytes());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 retransAckedNum = 9;
    if (has_retransackednum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->retransackednum());
    }

    // optional uint32 retransAckedBytes = 10;
    if (has_retransackedbytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->retransackedbytes());
    }

    // optional uint32 fastRetransNum = 11;
    if (has_fastretransnum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fastretransnum());
    }

    // optional uint32 fastRetransBytes = 12;
    if (has_fastretransbytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fastretransbytes());
    }

    // optional uint32 disorderPktNum = 13;
    if (has_disorderpktnum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->disorderpktnum());
    }

    // optional uint32 disorderBytes = 14;
    if (has_disorderbytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->disorderbytes());
    }

    // optional uint32 dupAckNum = 15;
    if (has_dupacknum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dupacknum());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TcpSessionNotify_FlowInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TcpSessionNotify_FlowInfo*>(&from));
}

void TcpSessionNotify_FlowInfo::MergeFrom(const TcpSessionNotify_FlowInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_begintime()) {
      set_begintime(from.begintime());
    }
    if (from.has_endtime()) {
      set_endtime(from.endtime());
    }
    if (from.has_firstpayloadtime()) {
      set_firstpayloadtime(from.firstpayloadtime());
    }
    if (from.has_lastpayloadtime()) {
      set_lastpayloadtime(from.lastpayloadtime());
    }
    if (from.has_totalpktnum()) {
      set_totalpktnum(from.totalpktnum());
    }
    if (from.has_totalbytes()) {
      set_totalbytes(from.totalbytes());
    }
    if (from.has_retranspktnum()) {
      set_retranspktnum(from.retranspktnum());
    }
    if (from.has_retransbytes()) {
      set_retransbytes(from.retransbytes());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_retransackednum()) {
      set_retransackednum(from.retransackednum());
    }
    if (from.has_retransackedbytes()) {
      set_retransackedbytes(from.retransackedbytes());
    }
    if (from.has_fastretransnum()) {
      set_fastretransnum(from.fastretransnum());
    }
    if (from.has_fastretransbytes()) {
      set_fastretransbytes(from.fastretransbytes());
    }
    if (from.has_disorderpktnum()) {
      set_disorderpktnum(from.disorderpktnum());
    }
    if (from.has_disorderbytes()) {
      set_disorderbytes(from.disorderbytes());
    }
    if (from.has_dupacknum()) {
      set_dupacknum(from.dupacknum());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void TcpSessionNotify_FlowInfo::CopyFrom(const TcpSessionNotify_FlowInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TcpSessionNotify_FlowInfo::IsInitialized() const {

  return true;
}

void TcpSessionNotify_FlowInfo::Swap(TcpSessionNotify_FlowInfo* other) {
  if (other != this) {
    std::swap(begintime_, other->begintime_);
    std::swap(endtime_, other->endtime_);
    std::swap(firstpayloadtime_, other->firstpayloadtime_);
    std::swap(lastpayloadtime_, other->lastpayloadtime_);
    std::swap(totalpktnum_, other->totalpktnum_);
    std::swap(totalbytes_, other->totalbytes_);
    std::swap(retranspktnum_, other->retranspktnum_);
    std::swap(retransbytes_, other->retransbytes_);
    std::swap(retransackednum_, other->retransackednum_);
    std::swap(retransackedbytes_, other->retransackedbytes_);
    std::swap(fastretransnum_, other->fastretransnum_);
    std::swap(fastretransbytes_, other->fastretransbytes_);
    std::swap(disorderpktnum_, other->disorderpktnum_);
    std::swap(disorderbytes_, other->disorderbytes_);
    std::swap(dupacknum_, other->dupacknum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TcpSessionNotify_FlowInfo::GetTypeName() const {
  return "com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TcpSessionNotify::kSessionIdFieldNumber;
const int TcpSessionNotify::kIpportFieldNumber;
const int TcpSessionNotify::kRttFieldNumber;
const int TcpSessionNotify::kDlInfoFieldNumber;
const int TcpSessionNotify::kUlInfoFieldNumber;
#endif  // !_MSC_VER

TcpSessionNotify::TcpSessionNotify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.zte.netanalysis.capcontrol.TcpSessionNotify)
}

void TcpSessionNotify::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  ipport_ = const_cast< ::com::zte::netanalysis::capcontrol::TcpSessionNotify_IpPort*>(
      ::com::zte::netanalysis::capcontrol::TcpSessionNotify_IpPort::internal_default_instance());
#else
  ipport_ = const_cast< ::com::zte::netanalysis::capcontrol::TcpSessionNotify_IpPort*>(&::com::zte::netanalysis::capcontrol::TcpSessionNotify_IpPort::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  dlinfo_ = const_cast< ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo*>(
      ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo::internal_default_instance());
#else
  dlinfo_ = const_cast< ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo*>(&::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  ulinfo_ = const_cast< ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo*>(
      ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo::internal_default_instance());
#else
  ulinfo_ = const_cast< ::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo*>(&::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo::default_instance());
#endif
}

TcpSessionNotify::TcpSessionNotify(const TcpSessionNotify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.zte.netanalysis.capcontrol.TcpSessionNotify)
}

void TcpSessionNotify::SharedCtor() {
  _cached_size_ = 0;
  sessionid_ = 0u;
  ipport_ = NULL;
  rtt_ = 0u;
  dlinfo_ = NULL;
  ulinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TcpSessionNotify::~TcpSessionNotify() {
  // @@protoc_insertion_point(destructor:com.zte.netanalysis.capcontrol.TcpSessionNotify)
  SharedDtor();
}

void TcpSessionNotify::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete ipport_;
    delete dlinfo_;
    delete ulinfo_;
  }
}

void TcpSessionNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TcpSessionNotify& TcpSessionNotify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

TcpSessionNotify* TcpSessionNotify::default_instance_ = NULL;

TcpSessionNotify* TcpSessionNotify::New() const {
  return new TcpSessionNotify;
}

void TcpSessionNotify::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TcpSessionNotify*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(sessionid_, rtt_);
    if (has_ipport()) {
      if (ipport_ != NULL) ipport_->::com::zte::netanalysis::capcontrol::TcpSessionNotify_IpPort::Clear();
    }
    if (has_dlinfo()) {
      if (dlinfo_ != NULL) dlinfo_->::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo::Clear();
    }
    if (has_ulinfo()) {
      if (ulinfo_ != NULL) ulinfo_->::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool TcpSessionNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.zte.netanalysis.capcontrol.TcpSessionNotify)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 sessionId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sessionid_)));
          set_has_sessionid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(19)) goto parse_ipport;
        break;
      }

      // optional group IpPort = 2 {
      case 2: {
        if (tag == 19) {
         parse_ipport:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                2, input, mutable_ipport()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_rtt;
        break;
      }

      // optional uint32 rtt = 3;
      case 3: {
        if (tag == 24) {
         parse_rtt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rtt_)));
          set_has_rtt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_dlInfo;
        break;
      }

      // optional .com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo dlInfo = 4;
      case 4: {
        if (tag == 34) {
         parse_dlInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dlinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_ulInfo;
        break;
      }

      // optional .com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo ulInfo = 5;
      case 5: {
        if (tag == 42) {
         parse_ulInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ulinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.zte.netanalysis.capcontrol.TcpSessionNotify)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.zte.netanalysis.capcontrol.TcpSessionNotify)
  return false;
#undef DO_
}

void TcpSessionNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.zte.netanalysis.capcontrol.TcpSessionNotify)
  // required uint32 sessionId = 1;
  if (has_sessionid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sessionid(), output);
  }

  // optional group IpPort = 2 {
  if (has_ipport()) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      2, this->ipport(), output);
  }

  // optional uint32 rtt = 3;
  if (has_rtt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->rtt(), output);
  }

  // optional .com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo dlInfo = 4;
  if (has_dlinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->dlinfo(), output);
  }

  // optional .com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo ulInfo = 5;
  if (has_ulinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->ulinfo(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.zte.netanalysis.capcontrol.TcpSessionNotify)
}

int TcpSessionNotify::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 sessionId = 1;
    if (has_sessionid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sessionid());
    }

    // optional group IpPort = 2 {
    if (has_ipport()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
          this->ipport());
    }

    // optional uint32 rtt = 3;
    if (has_rtt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rtt());
    }

    // optional .com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo dlInfo = 4;
    if (has_dlinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dlinfo());
    }

    // optional .com.zte.netanalysis.capcontrol.TcpSessionNotify.FlowInfo ulInfo = 5;
    if (has_ulinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ulinfo());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TcpSessionNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TcpSessionNotify*>(&from));
}

void TcpSessionNotify::MergeFrom(const TcpSessionNotify& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sessionid()) {
      set_sessionid(from.sessionid());
    }
    if (from.has_ipport()) {
      mutable_ipport()->::com::zte::netanalysis::capcontrol::TcpSessionNotify_IpPort::MergeFrom(from.ipport());
    }
    if (from.has_rtt()) {
      set_rtt(from.rtt());
    }
    if (from.has_dlinfo()) {
      mutable_dlinfo()->::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo::MergeFrom(from.dlinfo());
    }
    if (from.has_ulinfo()) {
      mutable_ulinfo()->::com::zte::netanalysis::capcontrol::TcpSessionNotify_FlowInfo::MergeFrom(from.ulinfo());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void TcpSessionNotify::CopyFrom(const TcpSessionNotify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TcpSessionNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_ipport()) {
    if (!this->ipport().IsInitialized()) return false;
  }
  return true;
}

void TcpSessionNotify::Swap(TcpSessionNotify* other) {
  if (other != this) {
    std::swap(sessionid_, other->sessionid_);
    std::swap(ipport_, other->ipport_);
    std::swap(rtt_, other->rtt_);
    std::swap(dlinfo_, other->dlinfo_);
    std::swap(ulinfo_, other->ulinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TcpSessionNotify::GetTypeName() const {
  return "com.zte.netanalysis.capcontrol.TcpSessionNotify";
}


// ===================================================================

#ifndef _MSC_VER
const int DnsTransNotify::kRetryCountFieldNumber;
const int DnsTransNotify::kQueryTimeFieldNumber;
const int DnsTransNotify::kAnswerTimeFieldNumber;
const int DnsTransNotify::kDnsServerIpFieldNumber;
const int DnsTransNotify::kHostNameFieldNumber;
const int DnsTransNotify::kIpAddrFieldNumber;
#endif  // !_MSC_VER

DnsTransNotify::DnsTransNotify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.zte.netanalysis.capcontrol.DnsTransNotify)
}

void DnsTransNotify::InitAsDefaultInstance() {
}

DnsTransNotify::DnsTransNotify(const DnsTransNotify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.zte.netanalysis.capcontrol.DnsTransNotify)
}

void DnsTransNotify::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  retrycount_ = 0u;
  querytime_ = GOOGLE_ULONGLONG(0);
  answertime_ = GOOGLE_ULONGLONG(0);
  dnsserverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ipaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DnsTransNotify::~DnsTransNotify() {
  // @@protoc_insertion_point(destructor:com.zte.netanalysis.capcontrol.DnsTransNotify)
  SharedDtor();
}

void DnsTransNotify::SharedDtor() {
  if (dnsserverip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dnsserverip_;
  }
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (ipaddr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ipaddr_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DnsTransNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DnsTransNotify& DnsTransNotify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

DnsTransNotify* DnsTransNotify::default_instance_ = NULL;

DnsTransNotify* DnsTransNotify::New() const {
  return new DnsTransNotify;
}

void DnsTransNotify::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<DnsTransNotify*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(querytime_, answertime_);
    retrycount_ = 0u;
    if (has_dnsserverip()) {
      if (dnsserverip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        dnsserverip_->clear();
      }
    }
    if (has_hostname()) {
      if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        hostname_->clear();
      }
    }
    if (has_ipaddr()) {
      if (ipaddr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ipaddr_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool DnsTransNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.zte.netanalysis.capcontrol.DnsTransNotify)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 retryCount = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &retrycount_)));
          set_has_retrycount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_queryTime;
        break;
      }

      // optional uint64 queryTime = 2;
      case 2: {
        if (tag == 16) {
         parse_queryTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &querytime_)));
          set_has_querytime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_answerTime;
        break;
      }

      // optional uint64 answerTime = 3;
      case 3: {
        if (tag == 24) {
         parse_answerTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &answertime_)));
          set_has_answertime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_dnsServerIp;
        break;
      }

      // optional string dnsServerIp = 4;
      case 4: {
        if (tag == 34) {
         parse_dnsServerIp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_dnsserverip()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_hostName;
        break;
      }

      // optional string hostName = 5;
      case 5: {
        if (tag == 42) {
         parse_hostName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_ipAddr;
        break;
      }

      // optional string ipAddr = 6;
      case 6: {
        if (tag == 50) {
         parse_ipAddr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ipaddr()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.zte.netanalysis.capcontrol.DnsTransNotify)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.zte.netanalysis.capcontrol.DnsTransNotify)
  return false;
#undef DO_
}

void DnsTransNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.zte.netanalysis.capcontrol.DnsTransNotify)
  // optional uint32 retryCount = 1;
  if (has_retrycount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->retrycount(), output);
  }

  // optional uint64 queryTime = 2;
  if (has_querytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->querytime(), output);
  }

  // optional uint64 answerTime = 3;
  if (has_answertime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->answertime(), output);
  }

  // optional string dnsServerIp = 4;
  if (has_dnsserverip()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->dnsserverip(), output);
  }

  // optional string hostName = 5;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->hostname(), output);
  }

  // optional string ipAddr = 6;
  if (has_ipaddr()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->ipaddr(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.zte.netanalysis.capcontrol.DnsTransNotify)
}

int DnsTransNotify::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 retryCount = 1;
    if (has_retrycount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->retrycount());
    }

    // optional uint64 queryTime = 2;
    if (has_querytime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->querytime());
    }

    // optional uint64 answerTime = 3;
    if (has_answertime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->answertime());
    }

    // optional string dnsServerIp = 4;
    if (has_dnsserverip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->dnsserverip());
    }

    // optional string hostName = 5;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

    // optional string ipAddr = 6;
    if (has_ipaddr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ipaddr());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DnsTransNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DnsTransNotify*>(&from));
}

void DnsTransNotify::MergeFrom(const DnsTransNotify& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_retrycount()) {
      set_retrycount(from.retrycount());
    }
    if (from.has_querytime()) {
      set_querytime(from.querytime());
    }
    if (from.has_answertime()) {
      set_answertime(from.answertime());
    }
    if (from.has_dnsserverip()) {
      set_dnsserverip(from.dnsserverip());
    }
    if (from.has_hostname()) {
      set_hostname(from.hostname());
    }
    if (from.has_ipaddr()) {
      set_ipaddr(from.ipaddr());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void DnsTransNotify::CopyFrom(const DnsTransNotify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DnsTransNotify::IsInitialized() const {

  return true;
}

void DnsTransNotify::Swap(DnsTransNotify* other) {
  if (other != this) {
    std::swap(retrycount_, other->retrycount_);
    std::swap(querytime_, other->querytime_);
    std::swap(answertime_, other->answertime_);
    std::swap(dnsserverip_, other->dnsserverip_);
    std::swap(hostname_, other->hostname_);
    std::swap(ipaddr_, other->ipaddr_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DnsTransNotify::GetTypeName() const {
  return "com.zte.netanalysis.capcontrol.DnsTransNotify";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace capcontrol
}  // namespace netanalysis
}  // namespace zte
}  // namespace com

// @@protoc_insertion_point(global_scope)
